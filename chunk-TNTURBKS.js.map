{
  "version": 3,
  "sources": ["projects/devcrate/ngx-dc-data-sources/src/lib/base.data-source.ts", "projects/devcrate/ngx-dc-data-sources/src/lib/api.data-source.ts", "projects/devcrate/ngx-dc-data-sources/src/lib/infinite-scroller.data-source.ts", "projects/devcrate/ngx-dc-data-sources/src/public-api.ts", "projects/devcrate/ngx-dc-data-sources/src/devcrate-ngx-dc-data-sources.ts"],
  "sourcesContent": ["import {BehaviorSubject, firstValueFrom, Observable, of, Subscription, switchMap} from \"rxjs\";\nimport {HttpClient} from \"@angular/common/http\";\nimport {mergeWith, takeUntil} from \"rxjs/operators\";\nimport {CollectionViewer, DataSource} from \"@angular/cdk/collections\";\nimport {DestroyObservable} from \"@devcrate/ngx-dc-utils\";\n\nexport class PageableResult<T> {\n  results: T[]\n  count: number\n}\n\n/**\n * Base class to manage lists we retrieve from the server.\n * Dao stands for Data Access Object, implying that this is where we store the data.\n * This allows us to keep the data in one place and manage it in a consistent way through all our components.\n * You can extend this class to provide the specific data retrieval and transformation logic for your data.\n *\n * This is used in the ngx-dc-side-pane-list component and Material Components that require a DataSource like MatTable.\n *\n * By extending this class, you can pass this into the mat-table like so:\n * ```html\n * <table mat-table [dataSource]=\"dao\"> ... </table>\n */\nexport abstract class NgxDcDataSource<GetDataItemsT = any, FinalDataItemsT = GetDataItemsT> extends DestroyObservable implements DataSource<FinalDataItemsT> {\n  public data$ = new BehaviorSubject<FinalDataItemsT[]>([])\n  public count$ = new BehaviorSubject<number>(0)\n  public initialized = false\n  public loading = new BehaviorSubject(false)\n  public itemLoading = new BehaviorSubject(false)\n\n  public get actualDataLength(): number {\n    return this.data$.value.filter(a => !!a).length\n  }\n\n  public allowLocalFilter: boolean = false\n  public filter = new BehaviorSubject<string>(\"\")\n  public filteredData$: Observable<FinalDataItemsT[]>\n\n  constructor() {\n    super()\n    this.initializeFiltering()\n  }\n\n  /**\n   * This is added functionality on top of the DataSource object that Material provides.\n   *\n   * You can use this data source in any Material CDK component that requires a DataSource.\n   * You can also use it in a normal for loop like so:\n   *\n   * ```html\n   * <div *ngFor=\"let item of dao.filteredData$ | async\"></div>\n   * ```\n   *\n   * connect and disconnect functions are needing implemented to have the DataSource work.\n   *\n   * Since this is the base dao, we only have it return the filteredData$ observable.\n   *\n   * See {InfiniteSidePaneListBaseApiDao} for an example of how to use with paging.\n   *\n   * @returns An observable of the data we want to display\n   */\n  public connect(collectionViewer: CollectionViewer): Observable<readonly FinalDataItemsT[]> {\n    return this.filteredData$.pipe(takeUntil(this.destroy$))\n  }\n\n  public disconnect(collectionViewer: CollectionViewer): void {\n    this.onDestroy()\n    this.data$.complete()\n    this.itemLoading.complete()\n    this.loading.complete()\n  }\n\n  /**\n   * Initializes the ability to filter your data locally\n   */\n  public initializeFiltering() {\n    const dataOrFilterChanges$ = this.filter.pipe(\n      mergeWith(this.data$),\n      switchMap(() => of({ data: this.data$.value, filterValue: this.filter.value }))\n    )\n\n    this.filteredData$ = dataOrFilterChanges$.pipe(\n      switchMap(({ data, filterValue }) => {\n        if (!filterValue || !this.allowLocalFilter) {\n          return of(data)\n        }\n        return of(data.filter(item => item && this.filterPredicate(item, filterValue)))\n      })\n    )\n  }\n\n  /**\n   * Call this in your ngOnInit function to initialize the data of your Dao.\n   */\n  public async initialize() {\n    this.initialized = true\n    try {\n      this.loading.next(true)\n      await this.initializeData()\n    } finally {\n      this.loading.next(false)\n    }\n  }\n\n  /**\n   * Resets the data and count to empty.\n   */\n  public reset() {\n    this.data$.next([])\n    this.count$.next(0)\n  }\n\n  /**\n   * When we do local filtering, we need to convert the value to a string to compare it to the filter string.\n   * Override this method to provide custom string conversion for your data.\n   *\n   * For example:\n   *\n   * ```typescript\n   * public propToString(key: keyof FinalDataItemsT, value: any): string {\n   *   if (key === \"date\") {\n   *     return new Date(value).toLocaleDateString()\n   *   }\n   *   return value.toString()\n   * }\n   * ```\n   * @param key The name of the key in the data object (FinalDataItemsT[key])\n   * @param value The value of the key in the data object (FinalDataItemsT[key])\n   */\n  public propToString(key: keyof FinalDataItemsT, value: any): string {\n    if (value == null) { return \"\" }\n    return value.toString()\n  }\n\n  /**\n   * Adapted from Angular Material's MatTableDataSource\n   * See: https://github.com/angular/components/blob/04ce4d2648004e970bc864962e6ec12e92f27698/src/material/table/table-data-source.ts#L231\n   * Checks if a data object matches the data source's filter string. By default, each data object\n   * is converted to a string of its properties and returns true if the filter has\n   * at least one occurrence in that string. By default, the filter string has its whitespace\n   * trimmed and the match is case-insensitive. May be overridden for a custom implementation of\n   * filter matching.\n   *\n   * @param data Data object used to check against the filter.\n   * @param filter Filter string that has been set on the data source.\n   *\n   * @returns Whether the filter matches against the data\n   */\n  protected filterPredicate(data: FinalDataItemsT, filter: string): boolean {\n    // Transform the data into a lowercase string of all property values.\n    const dataStr = Object.keys(data)\n      .reduce((currentTerm: string, key: string) => {\n        // Use an obscure Unicode character to delimit the words in the concatenated string.\n        // This avoids matches where the values of two columns combined will match the user's query\n        // (e.g. `Flute` and `Stop` will match `Test`). The character is intended to be something\n        // that has a very low chance of being typed in by somebody in a text field. This one in\n        // particular is \"White up-pointing triangle with dot\" from\n        // https://en.wikipedia.org/wiki/List_of_Unicode_characters\n        const nextValue = data[key]\n        return currentTerm + this.propToString(key as keyof FinalDataItemsT, nextValue) + 'â—¬';\n      }, '')\n      .toLowerCase();\n\n    // Transform the filter by converting it to lowercase and removing whitespace.\n    const transformedFilter = filter.trim().toLowerCase();\n\n    return dataStr.indexOf(transformedFilter) != -1;\n  }\n\n  /**\n   * This is called in the initialize function to retrieve and transform the data.\n   * Use `retrieveDataItems` to get the data from the server or local storage.\n   * Use `transformDataItems` to transform the data into the format you want.\n   *\n   * @param paramOverrides Any parameters to override the set {this.params} object\n   */\n  public async retrieveFinalData(paramOverrides?: any): Promise<PageableResult<FinalDataItemsT>> {\n    const pagedDataItems = await this.retrieveDataItems(paramOverrides)\n    return await this.transformDataItems(pagedDataItems)\n  }\n\n  /**\n   * This is meant to be called in the component we use the dao so the component controls when the data loads\n   */\n  public async initializeData(): Promise<PageableResult<FinalDataItemsT>> {\n    const transformedData = await this.retrieveFinalData()\n    this.data$.next(transformedData.results)\n    this.count$.next(transformedData.count || transformedData.results.length)\n    return transformedData\n  }\n\n  /**\n   * This is called when dao.initialize() is called to get the data (whether from the server or somewhere else).\n   * This is the function that should be overridden to get the data from the server.\n   * If you don't need paged data, just do something like\n   * ```typescript\n   *   return { count: data.length, results: data }\n   * ```\n   *\n   * @param overrideParams Any parameters to override the set {this.params} object\n   */\n  public abstract retrieveDataItems(paramOverrides?: any): Promise<PageableResult<GetDataItemsT>>\n\n  /**\n   * This is meant to be called to be overridden if needed to handle retrieval items of data.\n   *\n   * This is very helpful if you need to transform the data into some ViewModel for your page/component.\n   *\n   * @param data The data retrieved from the server\n   * @returns The data in the format you want\n   */\n  public async transformDataItems(data: PageableResult<GetDataItemsT>): Promise<PageableResult<FinalDataItemsT>> {\n    return data as unknown as PageableResult<FinalDataItemsT>\n  }\n\n  /**\n   * Refreshes the dao by calling getDataItems. The purpose of this is the update params or some other item in the dao, then call refresh.\n   */\n  public async refresh(): Promise<PageableResult<FinalDataItemsT>> {\n    this.loading.next(true)\n    const results = await this.initializeData()\n    this.loading.next(false)\n    return results\n  }\n\n}\n", "import {HttpClient, HttpResponse} from \"@angular/common/http\";\nimport {firstValueFrom} from \"rxjs\";\nimport {NgxDcDataSource, PageableResult} from \"./base.data-source\";\n\n/**\n * Extends functionality of the BaseDao, but retrieves the data from an API endpoint.\n *\n * This is the most common use case for Dao's; retrieving data from an API.\n */\nexport abstract class NgxDcApiDataSource<\n  GetDataItemsT, FinalDataItemsT = GetDataItemsT, AllowedParamsT = any\n> extends NgxDcDataSource<GetDataItemsT, FinalDataItemsT> {\n  public abstract relativePath: string\n  public params: Partial<AllowedParamsT> = {}\n  public abstract trackItems(item: FinalDataItemsT): any\n\n  protected constructor(protected httpClient: HttpClient) {\n    super();\n  }\n\n  /**\n   * This allows you to overrride the default behavior of the infinite scroller to set any params based on the\n   * next page the scroll wants.\n   * @param params\n   */\n  public getParams(params: {[key: string]: any }): {[key: string]: any } {\n    return params\n  }\n\n  /**\n   * This allows you to overrride the default behavior of the infinite scroller to set any params based on the\n   * next page the scroll wants.\n   *\n   * This is called each time you initialize or call refresh in the data source (and potentially other cases).\n   */\n  public getCount(response: HttpResponse<GetDataItemsT[]>): number {\n    const xTotalCount = response.headers.get(\"X-Total-Count\")\n    return xTotalCount === 'null' ? null : parseInt(xTotalCount || \"0\", 10)\n  }\n\n  /**\n   * Allows you to override how you get the data for the data source, once its retrieved from the response.\n   *\n   * This is called each time you initialize or call refresh in the data source (and potentially other cases).\n   *\n   * @param response The response of the GET request made with the relativePath for this data source.\n   *\n   * @returns\n   */\n  public getResults(response: HttpResponse<GetDataItemsT[]>): GetDataItemsT[] {\n    return response.body\n  }\n\n  /**\n   * This is called when dao.initialize() is called to get the data (whether from the server or somewhere else).\n   * This is the function that should be overridden to get the data from the server.\n   * If you don't need paged data, just do something like\n   * ```typescript\n   *   return { count: data.length, results: data }\n   * ```\n   *\n   * @param overrideParams Any parameters to override the set {this.params} object\n   */\n  public async retrieveDataItems(overrideParams: any = null): Promise<PageableResult<GetDataItemsT>> {\n    const response = await firstValueFrom(this.httpClient.get<GetDataItemsT[]>(this.relativePath, {\n      params: this.getParams(overrideParams || this.params),\n      observe: 'response',\n    }))\n\n    return <PageableResult<GetDataItemsT>>{\n      count: this.getCount(response),\n      results: this.getResults(response)\n    }\n  }\n}\n", "import {CollectionViewer, DataSource} from \"@angular/cdk/collections\";\nimport {BehaviorSubject, firstValueFrom, Observable, Subscription} from \"rxjs\";\nimport {HttpClient, HttpResponse} from \"@angular/common/http\";\nimport {NgxDcApiDataSource} from \"./api.data-source\";\nimport {PageableResult} from \"./base.data-source\";\n\nexport const INFINITE_DEFAULT_MAX_TOTAL_COUNT = 1000\nexport const INFINITE_DEFAULT_PAGE_SIZE = 25\n\n/**\n * If you need to get data from the server and use infinite scrolling, then use this class.\n * It can be used for `app-side-pane-list` component or a CdkVirtualFor.\n */\nexport abstract class NgxDcInfiniteScrollDataSource<\n  GetDataItemsT = any, FinalDataItemsT = GetDataItemsT, AllowedParamsT = any\n> extends NgxDcApiDataSource<GetDataItemsT, FinalDataItemsT, AllowedParamsT>\n  implements DataSource<FinalDataItemsT> {\n  /**\n   * This is meant to be used to determine the height of each row in the list pane so infinite\n   * scrolling behaves as it should\n   */\n  public abstract rowHeight: number\n\n  /** The relative path to the endpoint on the server to get the list pane data from */\n  public abstract relativePath: string\n\n  /** Needed to have a set of items added so that when we get the visible data, we only replace that part of the array instead of adding and changing the scroll position */\n  public maxTotalCount: number = INFINITE_DEFAULT_MAX_TOTAL_COUNT\n\n  /** Needed for paging */\n  public pageSize: number = INFINITE_DEFAULT_PAGE_SIZE\n\n  /** The parameters to send to the server as params when making the http GET request using the {relativePath} */\n  public params: Partial<AllowedParamsT> = {} as any\n\n  /** The pages we have queried from the server */\n  private fetchedPages: Set<number> = new Set<number>()\n\n  private cachedData: FinalDataItemsT[]\n  private subscription: Subscription\n\n  /** The current page the user is on (based on the scroll position on the list pane) */\n  private lastPageAccessed: number\n\n  protected constructor(httpClient: HttpClient) {\n    super(httpClient)\n    this.prepareInfiniteScroller()\n  }\n\n  /**\n   * This allows you to overrride the default behavior of the infinite scroller to set any params based on the\n   * next page the scroll wants.\n   * @param params\n   */\n  public getParams(params: {[key: string]: any }): {[key: string]: any } {\n    return params\n  }\n\n  /**\n   * This allows you to overrride the default behavior of the infinite scroller to set any params based on the\n   * next page the scroll wants.\n   *\n   * This is called each time you initialize or call refresh in the data source (and potentially other cases).\n   */\n  public getCount(response: HttpResponse<GetDataItemsT[]>): number {\n    const xTotalCount = response.headers.get(\"X-Total-Count\")\n    return xTotalCount === 'null' ? null : parseInt(xTotalCount || \"0\", 10)\n  }\n\n  /**\n   * Allows you to override how you get the data for the data source, once its retrieved from the response.\n   *\n   * This is called each time you initialize or call refresh in the data source (and potentially other cases).\n   *\n   * @param response The response of the GET request made with the relativePath for this data source.\n   *\n   * @returns\n   */\n  public getResults(response: HttpResponse<GetDataItemsT[]>): GetDataItemsT[] {\n    return response.body\n  }\n\n  public async retrieveDataItems(overrideParams: any = null): Promise<PageableResult<GetDataItemsT>> {\n    const response = await firstValueFrom(this.httpClient.get<GetDataItemsT[]>(this.relativePath, {\n      params: this.getParams(overrideParams || this.params),\n      observe: 'response',\n    }))\n\n    return <PageableResult<GetDataItemsT>>{\n      count: this.getCount(response),\n      results: this.getResults(response),\n    }\n  }\n\n  /**\n   * This sets up the infinite scroller with an array full of null items so that the scrolling bar\n   * doesn't change in size.\n   *\n   * This is called in the constructor of the class.\n   */\n  public prepareInfiniteScroller() {\n    this.cachedData = Array.from<FinalDataItemsT>({length: this.maxTotalCount});\n    this.fetchedPages = new Set<number>();\n    // Putting in an empty array with null values for the length will trigger the connect function to run from *cdkInfiniteScroller\n    this.data$ = new BehaviorSubject<FinalDataItemsT[]>(this.cachedData);\n    // Initialize filtering here after the data$ is filled so the filter is able to initialize\n    this.initializeFiltering()\n  }\n\n  /**\n   * Ensures that if you need to put initialize back to its original state, you can override `initialize` with this one.\n   */\n  public async originalInitialize() {\n    return super.initialize()\n  }\n\n  public override async initialize(): Promise<void> {\n    // Ignore it for infinite scroller since connect function is called\n  }\n\n  /**\n   * Ensures that if you need to put refresh back to its original state, you can override `refresh` with this one.\n   */\n  public async originalRefresh() {\n    return super.refresh()\n  }\n\n  /**\n   * Infinite scrolling works a bit different from a normal data retrieval. Generally, when you want to update the data\n   * you can call `refresh` and it will clear the data and get all the data again. However, with infinite scrolling is\n   * based on the scroll position, so we need to clear all the data except the current page, and then get the data for\n   * that current page again. This way, as you scroll, the data is fetched as needed.\n   */\n  public clearAllItemsExceptCurrentPage() {\n    // reset all data to nulls\n    if (!this.lastPageAccessed) { this.lastPageAccessed = 0 }\n    const startIndex = this.lastPageAccessed * this.pageSize\n    const endIndex = startIndex + this.pageSize\n    this.cachedData = this.cachedData.map((item, i) => (i >= startIndex && i <= endIndex) ? item : null)\n    this.fetchedPages.clear()\n    // Putting in an empty array with null values for the length will trigger the connect function to run from *cdkInfiniteScroller\n    this.data$.next(this.cachedData)\n    this.count$.next(this.pageSize > this.actualDataLength ? this.actualDataLength : this.pageSize)\n  }\n\n  /**\n   * Allows you to still call refresh in the infinite scroller, but does it in a way that is more efficient for infinite\n   * scrolling.\n   */\n  public async refresh(): Promise<PageableResult<FinalDataItemsT>> {\n    this.loading.next(true)\n    this.clearAllItemsExceptCurrentPage()\n    await this.fetchPage(this.lastPageAccessed)\n    this.loading.next(false)\n    return <PageableResult<FinalDataItemsT>>{\n      results: this.data$.value,\n      count: this.count$.value,\n    }\n  }\n\n  /**\n   * Because we implement a DataSource, and use it in `*cdkVirtualFor=\"let item of dao\"`, we need to implement the\n   * connect and disconnect functions for the Material CDK Virtual Scroll to work and initialize.\n   *\n   * This called when the list pane is initialized with a collectionViewer.\n   * We subscribe to the collectionViewer to know what elements the user is currently viewing in the scroll list pane.\n   * It gives us a range with a start and end element. This is how we determine the start and end pages to fetch.\n   *\n   * At this point, we fetch all the pages that are currently in view and override those specific elements in the array.\n   *\n   * Then we return an observable that we want displayed in the list pane.\n   *\n   * We chose filteredData$, because we also want filtering functionality. Otherwise, we would use data$ instead.\n   * When there is no filter, filteredData$ is the same as data$.\n   *\n   * @param collectionViewer A way to know what elements are currently in view in the list pane\n   *\n   * @returns An observable of the data that is displayed in the list pane\n   */\n  public connect(collectionViewer: CollectionViewer): Observable<FinalDataItemsT[]> {\n    this.loading.next(true)\n    this.subscription = collectionViewer.viewChange.subscribe(async range => {\n      const startPage = this.getPageForIndex(range.start);\n      const endPage = this.getPageForIndex(range.end - 1);\n      const pagesToFetch = Array.from({ length: endPage - startPage + 1}).map((_, i) => {\n        return i + startPage;\n      })\n\n      for (const page of pagesToFetch) {\n        await this.fetchPage(page)\n      }\n      if (this.loading.value) {\n        this.loading.next(false)\n      }\n    })\n    return this.filteredData$;\n  }\n\n  /**\n   * The `*cdkVirtualFor=\"let item of dao\"` will call this when the component of the virtual for is destroyed.\n   */\n  public disconnect(): void {\n    this.subscription.unsubscribe();\n    this.loading.next(false)\n  }\n\n  /** Converts an index to the current page number */\n  private getPageForIndex(index: number): number {\n    return Math.floor(index / this.pageSize);\n  }\n\n  /**\n   * Retrieve pages data from the server.\n   *\n   * 1. Check to see if we already have the page\n   * 2. Set the last page accessed to the current page and add it to `fetchedPages`\n   * 3. Get the data from the server\n   * 4. Update certain indexes of the cached data with the new server data\n   * 5. Update the data$ BehaviorSubject with the new data which in turn updates the filteredData$.\n   * 6. Update the count$ BehaviorSubject with the new count\n   *\n   * @param page Page number 0+ to fetch. 0 is the first page\n   *\n   * @returns The newly cached updated data\n   */\n  public async fetchPage(page: number) {\n    if (this.fetchedPages.has(page)) { return null }\n    this.lastPageAccessed = page\n    const isFirstTime = !this.initialized\n    this.initialized = true\n    this.fetchedPages.add(page);\n\n    const startPage = page * this.pageSize\n    const pageData = await this.retrieveFinalData({\n      ...this.params,\n      ...this.getParams({\n        offset: startPage,\n        limit: this.pageSize,\n        includeCount: isFirstTime,\n      })\n    });\n    if (page > 0) {\n      pageData.count = this.count$.value\n    }\n    if (this.cachedData.length < pageData.count) {\n      this.cachedData = this.cachedData.concat(Array.from<FinalDataItemsT>({length: pageData.count - this.cachedData.length}));\n    } else if (this.cachedData.length > pageData.count) {\n      this.cachedData = this.cachedData.slice(0, pageData.count);\n    }\n    if (pageData.results.length === 0) {\n      this.cachedData = this.cachedData.filter(a => !!a)\n    } else {\n      this.cachedData.splice(startPage, this.pageSize, ...pageData.results);\n    }\n    this.data$.next(this.cachedData);\n    this.count$.next(pageData.count || this.cachedData.filter(a => !!a).length)\n    return this.cachedData\n  }\n}\n", "/*\n * Public API Surface of ngx-dc-data-sources\n */\n\nexport * from './lib/base.data-source';\nexport * from './lib/api.data-source';\nexport * from './lib/infinite-scroller.data-source';\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],
  "mappings": "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",
  "names": ["NgxDcDataSource", "DestroyObservable", "data$", "BehaviorSubject", "count$", "initialized", "loading", "itemLoading", "actualDataLength", "value", "filter", "a", "length", "allowLocalFilter", "filteredData$", "constructor", "initializeFiltering", "connect", "collectionViewer", "pipe", "takeUntil", "destroy$", "disconnect", "onDestroy", "complete", "dataOrFilterChanges$", "mergeWith", "switchMap", "of", "data", "filterValue", "item", "filterPredicate", "initialize", "__async", "next", "initializeData", "reset", "propToString", "key", "toString", "dataStr", "Object", "keys", "reduce", "currentTerm", "nextValue", "toLowerCase", "transformedFilter", "trim", "indexOf", "retrieveFinalData", "paramOverrides", "pagedDataItems", "retrieveDataItems", "transformDataItems", "transformedData", "results", "count", "refresh", "NgxDcApiDataSource", "httpClient", "params", "getParams", "getCount", "response", "xTotalCount", "headers", "get", "parseInt", "getResults", "body", "overrideParams", "firstValueFrom", "relativePath", "observe", "INFINITE_DEFAULT_MAX_TOTAL_COUNT", "INFINITE_DEFAULT_PAGE_SIZE"]
}
