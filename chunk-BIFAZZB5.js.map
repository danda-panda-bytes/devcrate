{"version":3,"sources":["node_modules/@angular/material/fesm2022/checkbox.mjs","node_modules/@angular/material/fesm2022/menu.mjs","projects/devcrate/ngx-dc-navbar/src/lib/navbar.directives.ts","projects/devcrate/ngx-dc-navbar/src/lib/navbar.service.ts","projects/devcrate/ngx-dc-navbar/src/lib/navbar.component.ts","projects/devcrate/ngx-dc-navbar/src/lib/navbar.component.html","projects/devcrate/ngx-dc-navbar/src/lib/navbar.module.ts","projects/devcrate/ngx-dc-navbar/src/public-api.ts","projects/devcrate/ngx-dc-navbar/src/devcrate-ngx-dc-navbar.ts"],"sourcesContent":["import { _IdGenerator } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, forwardRef, inject, ElementRef, ChangeDetectorRef, NgZone, ANIMATION_MODULE_TYPE, EventEmitter, HostAttributeToken, booleanAttribute, numberAttribute, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output, ViewChild, Directive, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS, CheckboxRequiredValidator } from '@angular/forms';\nimport { _StructuralStylesLoader, MatRipple, _MatInternalFormField, MatCommonModule } from '@angular/material/core';\nimport { _CdkPrivateStyleLoader } from '@angular/cdk/private';\n\n/** Injection token to be used to override the default options for `mat-checkbox`. */\nconst _c0 = [\"input\"];\nconst _c1 = [\"label\"];\nconst _c2 = [\"*\"];\nconst MAT_CHECKBOX_DEFAULT_OPTIONS = /*#__PURE__*/new InjectionToken('mat-checkbox-default-options', {\n  providedIn: 'root',\n  factory: MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY\n});\n/** @docs-private */\nfunction MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY() {\n  return {\n    color: 'accent',\n    clickAction: 'check-indeterminate',\n    disabledInteractive: false\n  };\n}\n\n/**\n * Represents the different states that require custom transitions between them.\n * @docs-private\n */\nvar TransitionCheckState = /*#__PURE__*/function (TransitionCheckState) {\n  /** The initial state of the component before any user interaction. */\n  TransitionCheckState[TransitionCheckState[\"Init\"] = 0] = \"Init\";\n  /** The state representing the component when it's becoming checked. */\n  TransitionCheckState[TransitionCheckState[\"Checked\"] = 1] = \"Checked\";\n  /** The state representing the component when it's becoming unchecked. */\n  TransitionCheckState[TransitionCheckState[\"Unchecked\"] = 2] = \"Unchecked\";\n  /** The state representing the component when it's becoming indeterminate. */\n  TransitionCheckState[TransitionCheckState[\"Indeterminate\"] = 3] = \"Indeterminate\";\n  return TransitionCheckState;\n}(TransitionCheckState || {});\n/**\n * @deprecated Will stop being exported.\n * @breaking-change 19.0.0\n */\nconst MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*#__PURE__*/forwardRef(() => MatCheckbox),\n  multi: true\n};\n/** Change event object emitted by checkbox. */\nclass MatCheckboxChange {\n  /** The source checkbox of the event. */\n  source;\n  /** The new `checked` value of the checkbox. */\n  checked;\n}\n// Default checkbox configuration.\nconst defaults = /*#__PURE__*/MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY();\nlet MatCheckbox = /*#__PURE__*/(() => {\n  class MatCheckbox {\n    _elementRef = inject(ElementRef);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _ngZone = inject(NgZone);\n    _animationMode = inject(ANIMATION_MODULE_TYPE, {\n      optional: true\n    });\n    _options = inject(MAT_CHECKBOX_DEFAULT_OPTIONS, {\n      optional: true\n    });\n    /** Focuses the checkbox. */\n    focus() {\n      this._inputElement.nativeElement.focus();\n    }\n    /** Creates the change event that will be emitted by the checkbox. */\n    _createChangeEvent(isChecked) {\n      const event = new MatCheckboxChange();\n      event.source = this;\n      event.checked = isChecked;\n      return event;\n    }\n    /** Gets the element on which to add the animation CSS classes. */\n    _getAnimationTargetElement() {\n      return this._inputElement?.nativeElement;\n    }\n    /** CSS classes to add when transitioning between the different checkbox states. */\n    _animationClasses = {\n      uncheckedToChecked: 'mdc-checkbox--anim-unchecked-checked',\n      uncheckedToIndeterminate: 'mdc-checkbox--anim-unchecked-indeterminate',\n      checkedToUnchecked: 'mdc-checkbox--anim-checked-unchecked',\n      checkedToIndeterminate: 'mdc-checkbox--anim-checked-indeterminate',\n      indeterminateToChecked: 'mdc-checkbox--anim-indeterminate-checked',\n      indeterminateToUnchecked: 'mdc-checkbox--anim-indeterminate-unchecked'\n    };\n    /**\n     * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will\n     * take precedence so this may be omitted.\n     */\n    ariaLabel = '';\n    /**\n     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n     */\n    ariaLabelledby = null;\n    /** The 'aria-describedby' attribute is read after the element's label and field type. */\n    ariaDescribedby;\n    /**\n     * Users can specify the `aria-expanded` attribute which will be forwarded to the input element\n     */\n    ariaExpanded;\n    /**\n     * Users can specify the `aria-controls` attribute which will be forwarded to the input element\n     */\n    ariaControls;\n    /** Users can specify the `aria-owns` attribute which will be forwarded to the input element */\n    ariaOwns;\n    _uniqueId;\n    /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */\n    id;\n    /** Returns the unique id for the visual hidden input. */\n    get inputId() {\n      return `${this.id || this._uniqueId}-input`;\n    }\n    /** Whether the checkbox is required. */\n    required;\n    /** Whether the label should appear after or before the checkbox. Defaults to 'after' */\n    labelPosition = 'after';\n    /** Name value will be applied to the input element if present */\n    name = null;\n    /** Event emitted when the checkbox's `checked` value changes. */\n    change = new EventEmitter();\n    /** Event emitted when the checkbox's `indeterminate` value changes. */\n    indeterminateChange = new EventEmitter();\n    /** The value attribute of the native input element */\n    value;\n    /** Whether the checkbox has a ripple. */\n    disableRipple;\n    /** The native `<input type=\"checkbox\">` element */\n    _inputElement;\n    /** The native `<label>` element */\n    _labelElement;\n    /** Tabindex for the checkbox. */\n    tabIndex;\n    // TODO(crisbeto): this should be a ThemePalette, but some internal apps were abusing\n    // the lack of type checking previously and assigning random strings.\n    /**\n     * Theme color of the checkbox. This API is supported in M2 themes only, it\n     * has no effect in M3 themes. For color customization in M3, see https://material.angular.io/components/checkbox/styling.\n     *\n     * For information on applying color variants in M3, see\n     * https://material.angular.io/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n     */\n    color;\n    /** Whether the checkbox should remain interactive when it is disabled. */\n    disabledInteractive;\n    /**\n     * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.\n     * @docs-private\n     */\n    _onTouched = () => {};\n    _currentAnimationClass = '';\n    _currentCheckState = TransitionCheckState.Init;\n    _controlValueAccessorChangeFn = () => {};\n    _validatorChangeFn = () => {};\n    constructor() {\n      inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);\n      const tabIndex = inject(new HostAttributeToken('tabindex'), {\n        optional: true\n      });\n      this._options = this._options || defaults;\n      this.color = this._options.color || defaults.color;\n      this.tabIndex = tabIndex == null ? 0 : parseInt(tabIndex) || 0;\n      this.id = this._uniqueId = inject(_IdGenerator).getId('mat-mdc-checkbox-');\n      this.disabledInteractive = this._options?.disabledInteractive ?? false;\n    }\n    ngOnChanges(changes) {\n      if (changes['required']) {\n        this._validatorChangeFn();\n      }\n    }\n    ngAfterViewInit() {\n      this._syncIndeterminate(this._indeterminate);\n    }\n    /** Whether the checkbox is checked. */\n    get checked() {\n      return this._checked;\n    }\n    set checked(value) {\n      if (value != this.checked) {\n        this._checked = value;\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    _checked = false;\n    /** Whether the checkbox is disabled. */\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(value) {\n      if (value !== this.disabled) {\n        this._disabled = value;\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    _disabled = false;\n    /**\n     * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\n     * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\n     * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately\n     * set to false.\n     */\n    get indeterminate() {\n      return this._indeterminate;\n    }\n    set indeterminate(value) {\n      const changed = value != this._indeterminate;\n      this._indeterminate = value;\n      if (changed) {\n        if (this._indeterminate) {\n          this._transitionCheckState(TransitionCheckState.Indeterminate);\n        } else {\n          this._transitionCheckState(this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);\n        }\n        this.indeterminateChange.emit(this._indeterminate);\n      }\n      this._syncIndeterminate(this._indeterminate);\n    }\n    _indeterminate = false;\n    _isRippleDisabled() {\n      return this.disableRipple || this.disabled;\n    }\n    /** Method being called whenever the label text changes. */\n    _onLabelTextChange() {\n      // Since the event of the `cdkObserveContent` directive runs outside of the zone, the checkbox\n      // component will be only marked for check, but no actual change detection runs automatically.\n      // Instead of going back into the zone in order to trigger a change detection which causes\n      // *all* components to be checked (if explicitly marked or not using OnPush), we only trigger\n      // an explicit change detection for the checkbox view and its children.\n      this._changeDetectorRef.detectChanges();\n    }\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value) {\n      this.checked = !!value;\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn) {\n      this._controlValueAccessorChangeFn = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    // Implemented as a part of Validator.\n    validate(control) {\n      return this.required && control.value !== true ? {\n        'required': true\n      } : null;\n    }\n    // Implemented as a part of Validator.\n    registerOnValidatorChange(fn) {\n      this._validatorChangeFn = fn;\n    }\n    _transitionCheckState(newState) {\n      let oldState = this._currentCheckState;\n      let element = this._getAnimationTargetElement();\n      if (oldState === newState || !element) {\n        return;\n      }\n      if (this._currentAnimationClass) {\n        element.classList.remove(this._currentAnimationClass);\n      }\n      this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);\n      this._currentCheckState = newState;\n      if (this._currentAnimationClass.length > 0) {\n        element.classList.add(this._currentAnimationClass);\n        // Remove the animation class to avoid animation when the checkbox is moved between containers\n        const animationClass = this._currentAnimationClass;\n        this._ngZone.runOutsideAngular(() => {\n          setTimeout(() => {\n            element.classList.remove(animationClass);\n          }, 1000);\n        });\n      }\n    }\n    _emitChangeEvent() {\n      this._controlValueAccessorChangeFn(this.checked);\n      this.change.emit(this._createChangeEvent(this.checked));\n      // Assigning the value again here is redundant, but we have to do it in case it was\n      // changed inside the `change` listener which will cause the input to be out of sync.\n      if (this._inputElement) {\n        this._inputElement.nativeElement.checked = this.checked;\n      }\n    }\n    /** Toggles the `checked` state of the checkbox. */\n    toggle() {\n      this.checked = !this.checked;\n      this._controlValueAccessorChangeFn(this.checked);\n    }\n    _handleInputClick() {\n      const clickAction = this._options?.clickAction;\n      // If resetIndeterminate is false, and the current state is indeterminate, do nothing on click\n      if (!this.disabled && clickAction !== 'noop') {\n        // When user manually click on the checkbox, `indeterminate` is set to false.\n        if (this.indeterminate && clickAction !== 'check') {\n          Promise.resolve().then(() => {\n            this._indeterminate = false;\n            this.indeterminateChange.emit(this._indeterminate);\n          });\n        }\n        this._checked = !this._checked;\n        this._transitionCheckState(this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);\n        // Emit our custom change event if the native input emitted one.\n        // It is important to only emit it, if the native input triggered one, because\n        // we don't want to trigger a change event, when the `checked` variable changes for example.\n        this._emitChangeEvent();\n      } else if (this.disabled && this.disabledInteractive || !this.disabled && clickAction === 'noop') {\n        // Reset native input when clicked with noop. The native checkbox becomes checked after\n        // click, reset it to be align with `checked` value of `mat-checkbox`.\n        this._inputElement.nativeElement.checked = this.checked;\n        this._inputElement.nativeElement.indeterminate = this.indeterminate;\n      }\n    }\n    _onInteractionEvent(event) {\n      // We always have to stop propagation on the change event.\n      // Otherwise the change event, from the input element, will bubble up and\n      // emit its event object to the `change` output.\n      event.stopPropagation();\n    }\n    _onBlur() {\n      // When a focused element becomes disabled, the browser *immediately* fires a blur event.\n      // Angular does not expect events to be raised during change detection, so any state change\n      // (such as a form control's 'ng-touched') will cause a changed-after-checked error.\n      // See https://github.com/angular/angular/issues/17793. To work around this, we defer\n      // telling the form control it has been touched until the next tick.\n      Promise.resolve().then(() => {\n        this._onTouched();\n        this._changeDetectorRef.markForCheck();\n      });\n    }\n    _getAnimationClassForCheckStateTransition(oldState, newState) {\n      // Don't transition if animations are disabled.\n      if (this._animationMode === 'NoopAnimations') {\n        return '';\n      }\n      switch (oldState) {\n        case TransitionCheckState.Init:\n          // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or\n          // [checked] bound to it.\n          if (newState === TransitionCheckState.Checked) {\n            return this._animationClasses.uncheckedToChecked;\n          } else if (newState == TransitionCheckState.Indeterminate) {\n            return this._checked ? this._animationClasses.checkedToIndeterminate : this._animationClasses.uncheckedToIndeterminate;\n          }\n          break;\n        case TransitionCheckState.Unchecked:\n          return newState === TransitionCheckState.Checked ? this._animationClasses.uncheckedToChecked : this._animationClasses.uncheckedToIndeterminate;\n        case TransitionCheckState.Checked:\n          return newState === TransitionCheckState.Unchecked ? this._animationClasses.checkedToUnchecked : this._animationClasses.checkedToIndeterminate;\n        case TransitionCheckState.Indeterminate:\n          return newState === TransitionCheckState.Checked ? this._animationClasses.indeterminateToChecked : this._animationClasses.indeterminateToUnchecked;\n      }\n      return '';\n    }\n    /**\n     * Syncs the indeterminate value with the checkbox DOM node.\n     *\n     * We sync `indeterminate` directly on the DOM node, because in Ivy the check for whether a\n     * property is supported on an element boils down to `if (propName in element)`. Domino's\n     * HTMLInputElement doesn't have an `indeterminate` property so Ivy will warn during\n     * server-side rendering.\n     */\n    _syncIndeterminate(value) {\n      const nativeCheckbox = this._inputElement;\n      if (nativeCheckbox) {\n        nativeCheckbox.nativeElement.indeterminate = value;\n      }\n    }\n    _onInputClick() {\n      this._handleInputClick();\n    }\n    _onTouchTargetClick() {\n      this._handleInputClick();\n      if (!this.disabled) {\n        // Normally the input should be focused already, but if the click\n        // comes from the touch target, then we might have to focus it ourselves.\n        this._inputElement.nativeElement.focus();\n      }\n    }\n    /**\n     *  Prevent click events that come from the `<label/>` element from bubbling. This prevents the\n     *  click handler on the host from triggering twice when clicking on the `<label/>` element. After\n     *  the click event on the `<label/>` propagates, the browsers dispatches click on the associated\n     *  `<input/>`. By preventing clicks on the label by bubbling, we ensure only one click event\n     *  bubbles when the label is clicked.\n     */\n    _preventBubblingFromLabel(event) {\n      if (!!event.target && this._labelElement.nativeElement.contains(event.target)) {\n        event.stopPropagation();\n      }\n    }\n    static ɵfac = function MatCheckbox_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatCheckbox)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatCheckbox,\n      selectors: [[\"mat-checkbox\"]],\n      viewQuery: function MatCheckbox_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 5);\n          i0.ɵɵviewQuery(_c1, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._inputElement = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._labelElement = _t.first);\n        }\n      },\n      hostAttrs: [1, \"mat-mdc-checkbox\"],\n      hostVars: 16,\n      hostBindings: function MatCheckbox_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"id\", ctx.id);\n          i0.ɵɵattribute(\"tabindex\", null)(\"aria-label\", null)(\"aria-labelledby\", null);\n          i0.ɵɵclassMap(ctx.color ? \"mat-\" + ctx.color : \"mat-accent\");\n          i0.ɵɵclassProp(\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\")(\"mdc-checkbox--disabled\", ctx.disabled)(\"mat-mdc-checkbox-disabled\", ctx.disabled)(\"mat-mdc-checkbox-checked\", ctx.checked)(\"mat-mdc-checkbox-disabled-interactive\", ctx.disabledInteractive);\n        }\n      },\n      inputs: {\n        ariaLabel: [0, \"aria-label\", \"ariaLabel\"],\n        ariaLabelledby: [0, \"aria-labelledby\", \"ariaLabelledby\"],\n        ariaDescribedby: [0, \"aria-describedby\", \"ariaDescribedby\"],\n        ariaExpanded: [2, \"aria-expanded\", \"ariaExpanded\", booleanAttribute],\n        ariaControls: [0, \"aria-controls\", \"ariaControls\"],\n        ariaOwns: [0, \"aria-owns\", \"ariaOwns\"],\n        id: \"id\",\n        required: [2, \"required\", \"required\", booleanAttribute],\n        labelPosition: \"labelPosition\",\n        name: \"name\",\n        value: \"value\",\n        disableRipple: [2, \"disableRipple\", \"disableRipple\", booleanAttribute],\n        tabIndex: [2, \"tabIndex\", \"tabIndex\", value => value == null ? undefined : numberAttribute(value)],\n        color: \"color\",\n        disabledInteractive: [2, \"disabledInteractive\", \"disabledInteractive\", booleanAttribute],\n        checked: [2, \"checked\", \"checked\", booleanAttribute],\n        disabled: [2, \"disabled\", \"disabled\", booleanAttribute],\n        indeterminate: [2, \"indeterminate\", \"indeterminate\", booleanAttribute]\n      },\n      outputs: {\n        change: \"change\",\n        indeterminateChange: \"indeterminateChange\"\n      },\n      exportAs: [\"matCheckbox\"],\n      features: [i0.ɵɵProvidersFeature([MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, {\n        provide: NG_VALIDATORS,\n        useExisting: MatCheckbox,\n        multi: true\n      }]), i0.ɵɵInputTransformsFeature, i0.ɵɵNgOnChangesFeature],\n      ngContentSelectors: _c2,\n      decls: 15,\n      vars: 23,\n      consts: [[\"checkbox\", \"\"], [\"input\", \"\"], [\"label\", \"\"], [\"mat-internal-form-field\", \"\", 3, \"click\", \"labelPosition\"], [1, \"mdc-checkbox\"], [1, \"mat-mdc-checkbox-touch-target\", 3, \"click\"], [\"type\", \"checkbox\", 1, \"mdc-checkbox__native-control\", 3, \"blur\", \"click\", \"change\", \"checked\", \"indeterminate\", \"disabled\", \"id\", \"required\", \"tabIndex\"], [1, \"mdc-checkbox__ripple\"], [1, \"mdc-checkbox__background\"], [\"focusable\", \"false\", \"viewBox\", \"0 0 24 24\", \"aria-hidden\", \"true\", 1, \"mdc-checkbox__checkmark\"], [\"fill\", \"none\", \"d\", \"M1.73,12.91 8.1,19.28 22.79,4.59\", 1, \"mdc-checkbox__checkmark-path\"], [1, \"mdc-checkbox__mixedmark\"], [\"mat-ripple\", \"\", 1, \"mat-mdc-checkbox-ripple\", \"mat-focus-indicator\", 3, \"matRippleTrigger\", \"matRippleDisabled\", \"matRippleCentered\"], [1, \"mdc-label\", 3, \"for\"]],\n      template: function MatCheckbox_Template(rf, ctx) {\n        if (rf & 1) {\n          const _r1 = i0.ɵɵgetCurrentView();\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelementStart(0, \"div\", 3);\n          i0.ɵɵlistener(\"click\", function MatCheckbox_Template_div_click_0_listener($event) {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx._preventBubblingFromLabel($event));\n          });\n          i0.ɵɵelementStart(1, \"div\", 4, 0)(3, \"div\", 5);\n          i0.ɵɵlistener(\"click\", function MatCheckbox_Template_div_click_3_listener() {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx._onTouchTargetClick());\n          });\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(4, \"input\", 6, 1);\n          i0.ɵɵlistener(\"blur\", function MatCheckbox_Template_input_blur_4_listener() {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx._onBlur());\n          })(\"click\", function MatCheckbox_Template_input_click_4_listener() {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx._onInputClick());\n          })(\"change\", function MatCheckbox_Template_input_change_4_listener($event) {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx._onInteractionEvent($event));\n          });\n          i0.ɵɵelementEnd();\n          i0.ɵɵelement(6, \"div\", 7);\n          i0.ɵɵelementStart(7, \"div\", 8);\n          i0.ɵɵnamespaceSVG();\n          i0.ɵɵelementStart(8, \"svg\", 9);\n          i0.ɵɵelement(9, \"path\", 10);\n          i0.ɵɵelementEnd();\n          i0.ɵɵnamespaceHTML();\n          i0.ɵɵelement(10, \"div\", 11);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelement(11, \"div\", 12);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(12, \"label\", 13, 2);\n          i0.ɵɵprojection(14);\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          const checkbox_r2 = i0.ɵɵreference(2);\n          i0.ɵɵproperty(\"labelPosition\", ctx.labelPosition);\n          i0.ɵɵadvance(4);\n          i0.ɵɵclassProp(\"mdc-checkbox--selected\", ctx.checked);\n          i0.ɵɵproperty(\"checked\", ctx.checked)(\"indeterminate\", ctx.indeterminate)(\"disabled\", ctx.disabled && !ctx.disabledInteractive)(\"id\", ctx.inputId)(\"required\", ctx.required)(\"tabIndex\", ctx.disabled && !ctx.disabledInteractive ? -1 : ctx.tabIndex);\n          i0.ɵɵattribute(\"aria-label\", ctx.ariaLabel || null)(\"aria-labelledby\", ctx.ariaLabelledby)(\"aria-describedby\", ctx.ariaDescribedby)(\"aria-checked\", ctx.indeterminate ? \"mixed\" : null)(\"aria-controls\", ctx.ariaControls)(\"aria-disabled\", ctx.disabled && ctx.disabledInteractive ? true : null)(\"aria-expanded\", ctx.ariaExpanded)(\"aria-owns\", ctx.ariaOwns)(\"name\", ctx.name)(\"value\", ctx.value);\n          i0.ɵɵadvance(7);\n          i0.ɵɵproperty(\"matRippleTrigger\", checkbox_r2)(\"matRippleDisabled\", ctx.disableRipple || ctx.disabled)(\"matRippleCentered\", true);\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"for\", ctx.inputId);\n        }\n      },\n      dependencies: [MatRipple, _MatInternalFormField],\n      styles: [\".mdc-checkbox{display:inline-block;position:relative;flex:0 0 18px;box-sizing:content-box;width:18px;height:18px;line-height:0;white-space:nowrap;cursor:pointer;vertical-align:bottom;padding:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);margin:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox:hover .mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:hover .mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus~.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active .mdc-checkbox__native-control~.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active .mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked~.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked~.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active .mdc-checkbox__native-control:checked~.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active .mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control~.mdc-checkbox__ripple{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control{position:absolute;margin:0;padding:0;opacity:0;cursor:inherit;width:var(--mdc-checkbox-state-layer-size, 40px);height:var(--mdc-checkbox-state-layer-size, 40px);top:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);right:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox--disabled{cursor:default;pointer-events:none}@media(forced-colors: active){.mdc-checkbox--disabled{opacity:.5}}.mdc-checkbox__background{display:inline-flex;position:absolute;align-items:center;justify-content:center;box-sizing:border-box;width:18px;height:18px;border:2px solid currentColor;border-radius:2px;background-color:rgba(0,0,0,0);pointer-events:none;will-change:background-color,border-color;transition:background-color 90ms cubic-bezier(0.4, 0, 0.6, 1),border-color 90ms cubic-bezier(0.4, 0, 0.6, 1);-webkit-print-color-adjust:exact;color-adjust:exact;border-color:var(--mdc-checkbox-unselected-icon-color, var(--mat-sys-on-surface-variant));top:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2)}.mdc-checkbox__native-control:enabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:enabled:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox__native-control:disabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:disabled:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox:hover .mdc-checkbox__native-control:not(:checked)~.mdc-checkbox__background,.mdc-checkbox:hover .mdc-checkbox__native-control:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-hover-icon-color, var(--mat-sys-on-surface));background-color:rgba(0,0,0,0)}.mdc-checkbox:hover .mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox:hover .mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary))}.mdc-checkbox__native-control:focus:focus:not(:checked)~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-focus-icon-color, var(--mat-sys-on-surface))}.mdc-checkbox__native-control:focus:focus:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox:hover .mdc-checkbox__native-control~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control:focus~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox__checkmark{position:absolute;top:0;right:0;bottom:0;left:0;width:100%;opacity:0;transition:opacity 180ms cubic-bezier(0.4, 0, 0.6, 1);color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}@media(forced-colors: active){.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox__checkmark-path{transition:stroke-dashoffset 180ms cubic-bezier(0.4, 0, 0.6, 1);stroke:currentColor;stroke-width:3.12px;stroke-dashoffset:29.7833385;stroke-dasharray:29.7833385}.mdc-checkbox__mixedmark{width:100%;height:0;transform:scaleX(0) rotate(0deg);border-width:1px;border-style:solid;opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1);border-color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__mixedmark{margin:0 1px}}.mdc-checkbox--disabled .mdc-checkbox__mixedmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__mixedmark{border-color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__background,.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__background,.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__background,.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__background{animation-duration:180ms;animation-timing-function:linear}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-unchecked-checked-checkmark-path 180ms linear;transition:none}.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-unchecked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-checked-unchecked-checkmark-path 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__checkmark{animation:mdc-checkbox-checked-indeterminate-checkmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-checked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__checkmark{animation:mdc-checkbox-indeterminate-checked-checkmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-checked-mixedmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-unchecked-mixedmark 300ms linear;transition:none}.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{transition:border-color 90ms cubic-bezier(0, 0, 0.2, 1),background-color 90ms cubic-bezier(0, 0, 0.2, 1)}.mdc-checkbox__native-control:checked~.mdc-checkbox__background .mdc-checkbox__checkmark-path,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background .mdc-checkbox__checkmark-path{stroke-dashoffset:0}.mdc-checkbox__native-control:checked~.mdc-checkbox__background .mdc-checkbox__checkmark{transition:opacity 180ms cubic-bezier(0, 0, 0.2, 1),transform 180ms cubic-bezier(0, 0, 0.2, 1);opacity:1}.mdc-checkbox__native-control:checked~.mdc-checkbox__background .mdc-checkbox__mixedmark{transform:scaleX(1) rotate(-45deg)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background .mdc-checkbox__checkmark{transform:rotate(45deg);opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background .mdc-checkbox__mixedmark{transform:scaleX(1) rotate(0deg);opacity:1}@keyframes mdc-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:29.7833385}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 1)}100%{stroke-dashoffset:0}}@keyframes mdc-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mdc-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);opacity:1;stroke-dashoffset:0}to{opacity:0;stroke-dashoffset:-29.7833385}}@keyframes mdc-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(45deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(45deg);opacity:0}to{transform:rotate(360deg);opacity:1}}@keyframes mdc-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(-45deg);opacity:0}to{transform:rotate(0deg);opacity:1}}@keyframes mdc-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(315deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;transform:scaleX(1);opacity:1}32.8%,100%{transform:scaleX(0);opacity:0}}.mat-mdc-checkbox{display:inline-block;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-checkbox._mat-animation-noopable .mdc-checkbox *,.mat-mdc-checkbox._mat-animation-noopable .mdc-checkbox *::before{transition:none !important;animation:none !important}.mat-mdc-checkbox label{cursor:pointer}.mat-mdc-checkbox .mat-internal-form-field{color:var(--mat-checkbox-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-checkbox-label-text-font, var(--mat-sys-body-medium-font));line-height:var(--mat-checkbox-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-checkbox-label-text-size, var(--mat-sys-body-medium-size));letter-spacing:var(--mat-checkbox-label-text-tracking, var(--mat-sys-body-medium-tracking));font-weight:var(--mat-checkbox-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive{pointer-events:auto}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive input{cursor:default}.mat-mdc-checkbox.mat-mdc-checkbox-disabled label{cursor:default;color:var(--mat-checkbox-disabled-label-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-checkbox label:empty{display:none}.mat-mdc-checkbox .mdc-checkbox__ripple{opacity:0}.mat-mdc-checkbox .mat-mdc-checkbox-ripple,.mdc-checkbox__ripple{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-checkbox .mat-mdc-checkbox-ripple:not(:empty),.mdc-checkbox__ripple:not(:empty){transform:translateZ(0)}.mat-mdc-checkbox-ripple .mat-ripple-element{opacity:.1}.mat-mdc-checkbox-touch-target{position:absolute;top:50%;left:50%;height:48px;width:48px;transform:translate(-50%, -50%);display:var(--mat-checkbox-touch-target-display, block)}.mat-mdc-checkbox .mat-mdc-checkbox-ripple::before{border-radius:50%}.mdc-checkbox__native-control:focus~.mat-focus-indicator::before{content:\\\"\\\"}\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatCheckbox;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated No longer used, `MatCheckbox` implements required validation directly.\n * @breaking-change 19.0.0\n */\nconst MAT_CHECKBOX_REQUIRED_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: /*#__PURE__*/forwardRef(() => MatCheckboxRequiredValidator),\n  multi: true\n};\n/**\n * Validator for Material checkbox's required attribute in template-driven checkbox.\n * Current CheckboxRequiredValidator only work with `input type=checkbox` and does not\n * work with `mat-checkbox`.\n *\n * @deprecated No longer used, `MatCheckbox` implements required validation directly.\n * @breaking-change 19.0.0\n */\nlet MatCheckboxRequiredValidator = /*#__PURE__*/(() => {\n  class MatCheckboxRequiredValidator extends CheckboxRequiredValidator {\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatCheckboxRequiredValidator_BaseFactory;\n      return function MatCheckboxRequiredValidator_Factory(__ngFactoryType__) {\n        return (ɵMatCheckboxRequiredValidator_BaseFactory || (ɵMatCheckboxRequiredValidator_BaseFactory = i0.ɵɵgetInheritedFactory(MatCheckboxRequiredValidator)))(__ngFactoryType__ || MatCheckboxRequiredValidator);\n      };\n    })();\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatCheckboxRequiredValidator,\n      selectors: [[\"mat-checkbox\", \"required\", \"\", \"formControlName\", \"\"], [\"mat-checkbox\", \"required\", \"\", \"formControl\", \"\"], [\"mat-checkbox\", \"required\", \"\", \"ngModel\", \"\"]],\n      features: [i0.ɵɵProvidersFeature([MAT_CHECKBOX_REQUIRED_VALIDATOR]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return MatCheckboxRequiredValidator;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated No longer used, `MatCheckbox` implements required validation directly.\n * @breaking-change 19.0.0\n */\nlet _MatCheckboxRequiredValidatorModule = /*#__PURE__*/(() => {\n  class _MatCheckboxRequiredValidatorModule {\n    static ɵfac = function _MatCheckboxRequiredValidatorModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _MatCheckboxRequiredValidatorModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: _MatCheckboxRequiredValidatorModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return _MatCheckboxRequiredValidatorModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatCheckboxModule = /*#__PURE__*/(() => {\n  class MatCheckboxModule {\n    static ɵfac = function MatCheckboxModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatCheckboxModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatCheckboxModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [MatCheckbox, MatCommonModule, MatCommonModule]\n    });\n  }\n  return MatCheckboxModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, MAT_CHECKBOX_DEFAULT_OPTIONS, MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY, MAT_CHECKBOX_REQUIRED_VALIDATOR, MatCheckbox, MatCheckboxChange, MatCheckboxModule, MatCheckboxRequiredValidator, TransitionCheckState, _MatCheckboxRequiredValidatorModule };\n","import * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, ChangeDetectorRef, booleanAttribute, Component, ChangeDetectionStrategy, ViewEncapsulation, Input, TemplateRef, ApplicationRef, Injector, ViewContainerRef, Directive, QueryList, EventEmitter, ANIMATION_MODULE_TYPE, afterNextRender, ContentChildren, ViewChild, ContentChild, Output, NgZone, NgModule } from '@angular/core';\nimport { FocusMonitor, _IdGenerator, FocusKeyManager, isFakeTouchstartFromScreenReader, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { UP_ARROW, DOWN_ARROW, RIGHT_ARROW, LEFT_ARROW, ESCAPE, hasModifierKey, ENTER, SPACE } from '@angular/cdk/keycodes';\nimport { Subject, merge, Subscription, of } from 'rxjs';\nimport { startWith, switchMap, takeUntil, take, filter } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\nimport { _StructuralStylesLoader, MatRipple, MatRippleModule, MatCommonModule } from '@angular/material/core';\nimport { _CdkPrivateStyleLoader } from '@angular/cdk/private';\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\n\n/**\n * Injection token used to provide the parent menu to menu-specific components.\n * @docs-private\n */\nconst _c0 = [\"mat-menu-item\", \"\"];\nconst _c1 = [[[\"mat-icon\"], [\"\", \"matMenuItemIcon\", \"\"]], \"*\"];\nconst _c2 = [\"mat-icon, [matMenuItemIcon]\", \"*\"];\nfunction MatMenuItem_Conditional_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"svg\", 2);\n    i0.ɵɵelement(1, \"polygon\", 3);\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c3 = [\"*\"];\nfunction MatMenu_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 0);\n    i0.ɵɵlistener(\"click\", function MatMenu_ng_template_0_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.closed.emit(\"click\"));\n    })(\"animationstart\", function MatMenu_ng_template_0_Template_div_animationstart_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._onAnimationStart($event.animationName));\n    })(\"animationend\", function MatMenu_ng_template_0_Template_div_animationend_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._onAnimationDone($event.animationName));\n    })(\"animationcancel\", function MatMenu_ng_template_0_Template_div_animationcancel_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._onAnimationDone($event.animationName));\n    });\n    i0.ɵɵelementStart(1, \"div\", 1);\n    i0.ɵɵprojection(2);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r1._classList);\n    i0.ɵɵclassProp(\"mat-menu-panel-animations-disabled\", ctx_r1._animationsDisabled)(\"mat-menu-panel-exit-animation\", ctx_r1._panelAnimationState === \"void\")(\"mat-menu-panel-animating\", ctx_r1._isAnimating);\n    i0.ɵɵproperty(\"id\", ctx_r1.panelId);\n    i0.ɵɵattribute(\"aria-label\", ctx_r1.ariaLabel || null)(\"aria-labelledby\", ctx_r1.ariaLabelledby || null)(\"aria-describedby\", ctx_r1.ariaDescribedby || null);\n  }\n}\nconst MAT_MENU_PANEL = /*#__PURE__*/new InjectionToken('MAT_MENU_PANEL');\n\n/**\n * Single item inside a `mat-menu`. Provides the menu item styling and accessibility treatment.\n */\nlet MatMenuItem = /*#__PURE__*/(() => {\n  class MatMenuItem {\n    _elementRef = inject(ElementRef);\n    _document = inject(DOCUMENT);\n    _focusMonitor = inject(FocusMonitor);\n    _parentMenu = inject(MAT_MENU_PANEL, {\n      optional: true\n    });\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    /** ARIA role for the menu item. */\n    role = 'menuitem';\n    /** Whether the menu item is disabled. */\n    disabled = false;\n    /** Whether ripples are disabled on the menu item. */\n    disableRipple = false;\n    /** Stream that emits when the menu item is hovered. */\n    _hovered = new Subject();\n    /** Stream that emits when the menu item is focused. */\n    _focused = new Subject();\n    /** Whether the menu item is highlighted. */\n    _highlighted = false;\n    /** Whether the menu item acts as a trigger for a sub-menu. */\n    _triggersSubmenu = false;\n    constructor() {\n      inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);\n      this._parentMenu?.addItem?.(this);\n    }\n    /** Focuses the menu item. */\n    focus(origin, options) {\n      if (this._focusMonitor && origin) {\n        this._focusMonitor.focusVia(this._getHostElement(), origin, options);\n      } else {\n        this._getHostElement().focus(options);\n      }\n      this._focused.next(this);\n    }\n    ngAfterViewInit() {\n      if (this._focusMonitor) {\n        // Start monitoring the element, so it gets the appropriate focused classes. We want\n        // to show the focus style for menu items only when the focus was not caused by a\n        // mouse or touch interaction.\n        this._focusMonitor.monitor(this._elementRef, false);\n      }\n    }\n    ngOnDestroy() {\n      if (this._focusMonitor) {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n      }\n      if (this._parentMenu && this._parentMenu.removeItem) {\n        this._parentMenu.removeItem(this);\n      }\n      this._hovered.complete();\n      this._focused.complete();\n    }\n    /** Used to set the `tabindex`. */\n    _getTabIndex() {\n      return this.disabled ? '-1' : '0';\n    }\n    /** Returns the host DOM element. */\n    _getHostElement() {\n      return this._elementRef.nativeElement;\n    }\n    /** Prevents the default element actions if it is disabled. */\n    _checkDisabled(event) {\n      if (this.disabled) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n    /** Emits to the hover stream. */\n    _handleMouseEnter() {\n      this._hovered.next(this);\n    }\n    /** Gets the label to be used when determining whether the option should be focused. */\n    getLabel() {\n      const clone = this._elementRef.nativeElement.cloneNode(true);\n      const icons = clone.querySelectorAll('mat-icon, .material-icons');\n      // Strip away icons, so they don't show up in the text.\n      for (let i = 0; i < icons.length; i++) {\n        icons[i].remove();\n      }\n      return clone.textContent?.trim() || '';\n    }\n    _setHighlighted(isHighlighted) {\n      // We need to mark this for check for the case where the content is coming from a\n      // `matMenuContent` whose change detection tree is at the declaration position,\n      // not the insertion position. See #23175.\n      this._highlighted = isHighlighted;\n      this._changeDetectorRef.markForCheck();\n    }\n    _setTriggersSubmenu(triggersSubmenu) {\n      this._triggersSubmenu = triggersSubmenu;\n      this._changeDetectorRef.markForCheck();\n    }\n    _hasFocus() {\n      return this._document && this._document.activeElement === this._getHostElement();\n    }\n    static ɵfac = function MatMenuItem_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatMenuItem)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatMenuItem,\n      selectors: [[\"\", \"mat-menu-item\", \"\"]],\n      hostAttrs: [1, \"mat-mdc-menu-item\", \"mat-focus-indicator\"],\n      hostVars: 8,\n      hostBindings: function MatMenuItem_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function MatMenuItem_click_HostBindingHandler($event) {\n            return ctx._checkDisabled($event);\n          })(\"mouseenter\", function MatMenuItem_mouseenter_HostBindingHandler() {\n            return ctx._handleMouseEnter();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx._getTabIndex())(\"aria-disabled\", ctx.disabled)(\"disabled\", ctx.disabled || null);\n          i0.ɵɵclassProp(\"mat-mdc-menu-item-highlighted\", ctx._highlighted)(\"mat-mdc-menu-item-submenu-trigger\", ctx._triggersSubmenu);\n        }\n      },\n      inputs: {\n        role: \"role\",\n        disabled: [2, \"disabled\", \"disabled\", booleanAttribute],\n        disableRipple: [2, \"disableRipple\", \"disableRipple\", booleanAttribute]\n      },\n      exportAs: [\"matMenuItem\"],\n      features: [i0.ɵɵInputTransformsFeature],\n      attrs: _c0,\n      ngContentSelectors: _c2,\n      decls: 5,\n      vars: 3,\n      consts: [[1, \"mat-mdc-menu-item-text\"], [\"matRipple\", \"\", 1, \"mat-mdc-menu-ripple\", 3, \"matRippleDisabled\", \"matRippleTrigger\"], [\"viewBox\", \"0 0 5 10\", \"focusable\", \"false\", \"aria-hidden\", \"true\", 1, \"mat-mdc-menu-submenu-icon\"], [\"points\", \"0,0 5,5 0,10\"]],\n      template: function MatMenuItem_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef(_c1);\n          i0.ɵɵprojection(0);\n          i0.ɵɵelementStart(1, \"span\", 0);\n          i0.ɵɵprojection(2, 1);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelement(3, \"div\", 1);\n          i0.ɵɵtemplate(4, MatMenuItem_Conditional_4_Template, 2, 0, \":svg:svg\", 2);\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(3);\n          i0.ɵɵproperty(\"matRippleDisabled\", ctx.disableRipple || ctx.disabled)(\"matRippleTrigger\", ctx._getHostElement());\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(ctx._triggersSubmenu ? 4 : -1);\n        }\n      },\n      dependencies: [MatRipple],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatMenuItem;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Throws an exception for the case when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n * @docs-private\n */\nfunction throwMatMenuInvalidPositionX() {\n  throw Error(`xPosition value must be either 'before' or after'.\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>`);\n}\n/**\n * Throws an exception for the case when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n * @docs-private\n */\nfunction throwMatMenuInvalidPositionY() {\n  throw Error(`yPosition value must be either 'above' or below'.\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>`);\n}\n/**\n * Throws an exception for the case when a menu is assigned\n * to a trigger that is placed inside the same menu.\n * @docs-private\n */\nfunction throwMatMenuRecursiveError() {\n  throw Error(`matMenuTriggerFor: menu cannot contain its own trigger. Assign a menu that is ` + `not a parent of the trigger or move the trigger outside of the menu.`);\n}\n\n/**\n * Injection token that can be used to reference instances of `MatMenuContent`. It serves\n * as alternative token to the actual `MatMenuContent` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_MENU_CONTENT = /*#__PURE__*/new InjectionToken('MatMenuContent');\n/** Menu content that will be rendered lazily once the menu is opened. */\nlet MatMenuContent = /*#__PURE__*/(() => {\n  class MatMenuContent {\n    _template = inject(TemplateRef);\n    _appRef = inject(ApplicationRef);\n    _injector = inject(Injector);\n    _viewContainerRef = inject(ViewContainerRef);\n    _document = inject(DOCUMENT);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _portal;\n    _outlet;\n    /** Emits when the menu content has been attached. */\n    _attached = new Subject();\n    constructor() {}\n    /**\n     * Attaches the content with a particular context.\n     * @docs-private\n     */\n    attach(context = {}) {\n      if (!this._portal) {\n        this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n      }\n      this.detach();\n      if (!this._outlet) {\n        this._outlet = new DomPortalOutlet(this._document.createElement('div'), null, this._appRef, this._injector);\n      }\n      const element = this._template.elementRef.nativeElement;\n      // Because we support opening the same menu from different triggers (which in turn have their\n      // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n      // risk it staying attached to a pane that's no longer in the DOM.\n      element.parentNode.insertBefore(this._outlet.outletElement, element);\n      // When `MatMenuContent` is used in an `OnPush` component, the insertion of the menu\n      // content via `createEmbeddedView` does not cause the content to be seen as \"dirty\"\n      // by Angular. This causes the `@ContentChildren` for menu items within the menu to\n      // not be updated by Angular. By explicitly marking for check here, we tell Angular that\n      // it needs to check for new menu items and update the `@ContentChild` in `MatMenu`.\n      this._changeDetectorRef.markForCheck();\n      this._portal.attach(this._outlet, context);\n      this._attached.next();\n    }\n    /**\n     * Detaches the content.\n     * @docs-private\n     */\n    detach() {\n      if (this._portal?.isAttached) {\n        this._portal.detach();\n      }\n    }\n    ngOnDestroy() {\n      this.detach();\n      this._outlet?.dispose();\n    }\n    static ɵfac = function MatMenuContent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatMenuContent)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatMenuContent,\n      selectors: [[\"ng-template\", \"matMenuContent\", \"\"]],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MAT_MENU_CONTENT,\n        useExisting: MatMenuContent\n      }])]\n    });\n  }\n  return MatMenuContent;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Injection token to be used to override the default options for `mat-menu`. */\nconst MAT_MENU_DEFAULT_OPTIONS = /*#__PURE__*/new InjectionToken('mat-menu-default-options', {\n  providedIn: 'root',\n  factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY\n});\n/** @docs-private */\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\n  return {\n    overlapTrigger: false,\n    xPosition: 'after',\n    yPosition: 'below',\n    backdropClass: 'cdk-overlay-transparent-backdrop'\n  };\n}\n/** Name of the enter animation `@keyframes`. */\nconst ENTER_ANIMATION = '_mat-menu-enter';\n/** Name of the exit animation `@keyframes`. */\nconst EXIT_ANIMATION = '_mat-menu-exit';\nlet MatMenu = /*#__PURE__*/(() => {\n  class MatMenu {\n    _elementRef = inject(ElementRef);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _injector = inject(Injector);\n    _keyManager;\n    _xPosition;\n    _yPosition;\n    _firstItemFocusRef;\n    _exitFallbackTimeout;\n    /** Whether animations are currently disabled. */\n    _animationsDisabled;\n    /** All items inside the menu. Includes items nested inside another menu. */\n    _allItems;\n    /** Only the direct descendant menu items. */\n    _directDescendantItems = new QueryList();\n    /** Classes to be applied to the menu panel. */\n    _classList = {};\n    /** Current state of the panel animation. */\n    _panelAnimationState = 'void';\n    /** Emits whenever an animation on the menu completes. */\n    _animationDone = new Subject();\n    /** Whether the menu is animating. */\n    _isAnimating = false;\n    /** Parent menu of the current menu panel. */\n    parentMenu;\n    /** Layout direction of the menu. */\n    direction;\n    /** Class or list of classes to be added to the overlay panel. */\n    overlayPanelClass;\n    /** Class to be added to the backdrop element. */\n    backdropClass;\n    /** aria-label for the menu panel. */\n    ariaLabel;\n    /** aria-labelledby for the menu panel. */\n    ariaLabelledby;\n    /** aria-describedby for the menu panel. */\n    ariaDescribedby;\n    /** Position of the menu in the X axis. */\n    get xPosition() {\n      return this._xPosition;\n    }\n    set xPosition(value) {\n      if (value !== 'before' && value !== 'after' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throwMatMenuInvalidPositionX();\n      }\n      this._xPosition = value;\n      this.setPositionClasses();\n    }\n    /** Position of the menu in the Y axis. */\n    get yPosition() {\n      return this._yPosition;\n    }\n    set yPosition(value) {\n      if (value !== 'above' && value !== 'below' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throwMatMenuInvalidPositionY();\n      }\n      this._yPosition = value;\n      this.setPositionClasses();\n    }\n    /** @docs-private */\n    templateRef;\n    /**\n     * List of the items inside of a menu.\n     * @deprecated\n     * @breaking-change 8.0.0\n     */\n    items;\n    /**\n     * Menu content that will be rendered lazily.\n     * @docs-private\n     */\n    lazyContent;\n    /** Whether the menu should overlap its trigger. */\n    overlapTrigger;\n    /** Whether the menu has a backdrop. */\n    hasBackdrop;\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @param classes list of class names\n     */\n    set panelClass(classes) {\n      const previousPanelClass = this._previousPanelClass;\n      const newClassList = {\n        ...this._classList\n      };\n      if (previousPanelClass && previousPanelClass.length) {\n        previousPanelClass.split(' ').forEach(className => {\n          newClassList[className] = false;\n        });\n      }\n      this._previousPanelClass = classes;\n      if (classes && classes.length) {\n        classes.split(' ').forEach(className => {\n          newClassList[className] = true;\n        });\n        this._elementRef.nativeElement.className = '';\n      }\n      this._classList = newClassList;\n    }\n    _previousPanelClass;\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @deprecated Use `panelClass` instead.\n     * @breaking-change 8.0.0\n     */\n    get classList() {\n      return this.panelClass;\n    }\n    set classList(classes) {\n      this.panelClass = classes;\n    }\n    /** Event emitted when the menu is closed. */\n    closed = new EventEmitter();\n    /**\n     * Event emitted when the menu is closed.\n     * @deprecated Switch to `closed` instead\n     * @breaking-change 8.0.0\n     */\n    close = this.closed;\n    panelId = inject(_IdGenerator).getId('mat-menu-panel-');\n    constructor() {\n      const defaultOptions = inject(MAT_MENU_DEFAULT_OPTIONS);\n      this.overlayPanelClass = defaultOptions.overlayPanelClass || '';\n      this._xPosition = defaultOptions.xPosition;\n      this._yPosition = defaultOptions.yPosition;\n      this.backdropClass = defaultOptions.backdropClass;\n      this.overlapTrigger = defaultOptions.overlapTrigger;\n      this.hasBackdrop = defaultOptions.hasBackdrop;\n      this._animationsDisabled = inject(ANIMATION_MODULE_TYPE, {\n        optional: true\n      }) === 'NoopAnimations';\n    }\n    ngOnInit() {\n      this.setPositionClasses();\n    }\n    ngAfterContentInit() {\n      this._updateDirectDescendants();\n      this._keyManager = new FocusKeyManager(this._directDescendantItems).withWrap().withTypeAhead().withHomeAndEnd();\n      this._keyManager.tabOut.subscribe(() => this.closed.emit('tab'));\n      // If a user manually (programmatically) focuses a menu item, we need to reflect that focus\n      // change back to the key manager. Note that we don't need to unsubscribe here because _focused\n      // is internal and we know that it gets completed on destroy.\n      this._directDescendantItems.changes.pipe(startWith(this._directDescendantItems), switchMap(items => merge(...items.map(item => item._focused)))).subscribe(focusedItem => this._keyManager.updateActiveItem(focusedItem));\n      this._directDescendantItems.changes.subscribe(itemsList => {\n        // Move focus to another item, if the active item is removed from the list.\n        // We need to debounce the callback, because multiple items might be removed\n        // in quick succession.\n        const manager = this._keyManager;\n        if (this._panelAnimationState === 'enter' && manager.activeItem?._hasFocus()) {\n          const items = itemsList.toArray();\n          const index = Math.max(0, Math.min(items.length - 1, manager.activeItemIndex || 0));\n          if (items[index] && !items[index].disabled) {\n            manager.setActiveItem(index);\n          } else {\n            manager.setNextItemActive();\n          }\n        }\n      });\n    }\n    ngOnDestroy() {\n      this._keyManager?.destroy();\n      this._directDescendantItems.destroy();\n      this.closed.complete();\n      this._firstItemFocusRef?.destroy();\n      clearTimeout(this._exitFallbackTimeout);\n    }\n    /** Stream that emits whenever the hovered menu item changes. */\n    _hovered() {\n      // Coerce the `changes` property because Angular types it as `Observable<any>`\n      const itemChanges = this._directDescendantItems.changes;\n      return itemChanges.pipe(startWith(this._directDescendantItems), switchMap(items => merge(...items.map(item => item._hovered))));\n    }\n    /*\n     * Registers a menu item with the menu.\n     * @docs-private\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 9.0.0\n     */\n    addItem(_item) {}\n    /**\n     * Removes an item from the menu.\n     * @docs-private\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 9.0.0\n     */\n    removeItem(_item) {}\n    /** Handle a keyboard event from the menu, delegating to the appropriate action. */\n    _handleKeydown(event) {\n      const keyCode = event.keyCode;\n      const manager = this._keyManager;\n      switch (keyCode) {\n        case ESCAPE:\n          if (!hasModifierKey(event)) {\n            event.preventDefault();\n            this.closed.emit('keydown');\n          }\n          break;\n        case LEFT_ARROW:\n          if (this.parentMenu && this.direction === 'ltr') {\n            this.closed.emit('keydown');\n          }\n          break;\n        case RIGHT_ARROW:\n          if (this.parentMenu && this.direction === 'rtl') {\n            this.closed.emit('keydown');\n          }\n          break;\n        default:\n          if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\n            manager.setFocusOrigin('keyboard');\n          }\n          manager.onKeydown(event);\n          return;\n      }\n    }\n    /**\n     * Focus the first item in the menu.\n     * @param origin Action from which the focus originated. Used to set the correct styling.\n     */\n    focusFirstItem(origin = 'program') {\n      // Wait for `afterNextRender` to ensure iOS VoiceOver screen reader focuses the first item (#24735).\n      this._firstItemFocusRef?.destroy();\n      this._firstItemFocusRef = afterNextRender(() => {\n        const menuPanel = this._resolvePanel();\n        // If an item in the menuPanel is already focused, avoid overriding the focus.\n        if (!menuPanel || !menuPanel.contains(document.activeElement)) {\n          const manager = this._keyManager;\n          manager.setFocusOrigin(origin).setFirstItemActive();\n          // If there's no active item at this point, it means that all the items are disabled.\n          // Move focus to the menuPanel panel so keyboard events like Escape still work. Also this will\n          // give _some_ feedback to screen readers.\n          if (!manager.activeItem && menuPanel) {\n            menuPanel.focus();\n          }\n        }\n      }, {\n        injector: this._injector\n      });\n    }\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     */\n    resetActiveItem() {\n      this._keyManager.setActiveItem(-1);\n    }\n    /**\n     * @deprecated No longer used and will be removed.\n     * @breaking-change 21.0.0\n     */\n    setElevation(_depth) {}\n    /**\n     * Adds classes to the menu panel based on its position. Can be used by\n     * consumers to add specific styling based on the position.\n     * @param posX Position of the menu along the x axis.\n     * @param posY Position of the menu along the y axis.\n     * @docs-private\n     */\n    setPositionClasses(posX = this.xPosition, posY = this.yPosition) {\n      this._classList = {\n        ...this._classList,\n        ['mat-menu-before']: posX === 'before',\n        ['mat-menu-after']: posX === 'after',\n        ['mat-menu-above']: posY === 'above',\n        ['mat-menu-below']: posY === 'below'\n      };\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Callback that is invoked when the panel animation completes. */\n    _onAnimationDone(state) {\n      const isExit = state === EXIT_ANIMATION;\n      if (isExit || state === ENTER_ANIMATION) {\n        if (isExit) {\n          clearTimeout(this._exitFallbackTimeout);\n          this._exitFallbackTimeout = undefined;\n        }\n        this._animationDone.next(isExit ? 'void' : 'enter');\n        this._isAnimating = false;\n      }\n    }\n    _onAnimationStart(state) {\n      if (state === ENTER_ANIMATION || state === EXIT_ANIMATION) {\n        this._isAnimating = true;\n      }\n    }\n    _setIsOpen(isOpen) {\n      this._panelAnimationState = isOpen ? 'enter' : 'void';\n      if (isOpen) {\n        if (this._keyManager.activeItemIndex === 0) {\n          // Scroll the content element to the top as soon as the animation starts. This is necessary,\n          // because we move focus to the first item while it's still being animated, which can throw\n          // the browser off when it determines the scroll position. Alternatively we can move focus\n          // when the animation is done, however moving focus asynchronously will interrupt screen\n          // readers which are in the process of reading out the menu already. We take the `element`\n          // from the `event` since we can't use a `ViewChild` to access the pane.\n          const menuPanel = this._resolvePanel();\n          if (menuPanel) {\n            menuPanel.scrollTop = 0;\n          }\n        }\n      } else if (!this._animationsDisabled) {\n        // Some apps do `* { animation: none !important; }` in tests which will prevent the\n        // `animationend` event from firing. Since the exit animation is loading-bearing for\n        // removing the content from the DOM, add a fallback timer.\n        this._exitFallbackTimeout = setTimeout(() => this._onAnimationDone(EXIT_ANIMATION), 200);\n      }\n      // Animation events won't fire when animations are disabled so we simulate them.\n      if (this._animationsDisabled) {\n        setTimeout(() => {\n          this._onAnimationDone(isOpen ? ENTER_ANIMATION : EXIT_ANIMATION);\n        });\n      }\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Sets up a stream that will keep track of any newly-added menu items and will update the list\n     * of direct descendants. We collect the descendants this way, because `_allItems` can include\n     * items that are part of child menus, and using a custom way of registering items is unreliable\n     * when it comes to maintaining the item order.\n     */\n    _updateDirectDescendants() {\n      this._allItems.changes.pipe(startWith(this._allItems)).subscribe(items => {\n        this._directDescendantItems.reset(items.filter(item => item._parentMenu === this));\n        this._directDescendantItems.notifyOnChanges();\n      });\n    }\n    /** Gets the menu panel DOM node. */\n    _resolvePanel() {\n      let menuPanel = null;\n      if (this._directDescendantItems.length) {\n        // Because the `mat-menuPanel` is at the DOM insertion point, not inside the overlay, we don't\n        // have a nice way of getting a hold of the menuPanel panel. We can't use a `ViewChild` either\n        // because the panel is inside an `ng-template`. We work around it by starting from one of\n        // the items and walking up the DOM.\n        menuPanel = this._directDescendantItems.first._getHostElement().closest('[role=\"menu\"]');\n      }\n      return menuPanel;\n    }\n    static ɵfac = function MatMenu_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatMenu)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatMenu,\n      selectors: [[\"mat-menu\"]],\n      contentQueries: function MatMenu_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, MAT_MENU_CONTENT, 5);\n          i0.ɵɵcontentQuery(dirIndex, MatMenuItem, 5);\n          i0.ɵɵcontentQuery(dirIndex, MatMenuItem, 4);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.lazyContent = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._allItems = _t);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n        }\n      },\n      viewQuery: function MatMenu_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(TemplateRef, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);\n        }\n      },\n      hostVars: 3,\n      hostBindings: function MatMenu_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-label\", null)(\"aria-labelledby\", null)(\"aria-describedby\", null);\n        }\n      },\n      inputs: {\n        backdropClass: \"backdropClass\",\n        ariaLabel: [0, \"aria-label\", \"ariaLabel\"],\n        ariaLabelledby: [0, \"aria-labelledby\", \"ariaLabelledby\"],\n        ariaDescribedby: [0, \"aria-describedby\", \"ariaDescribedby\"],\n        xPosition: \"xPosition\",\n        yPosition: \"yPosition\",\n        overlapTrigger: [2, \"overlapTrigger\", \"overlapTrigger\", booleanAttribute],\n        hasBackdrop: [2, \"hasBackdrop\", \"hasBackdrop\", value => value == null ? null : booleanAttribute(value)],\n        panelClass: [0, \"class\", \"panelClass\"],\n        classList: \"classList\"\n      },\n      outputs: {\n        closed: \"closed\",\n        close: \"close\"\n      },\n      exportAs: [\"matMenu\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MAT_MENU_PANEL,\n        useExisting: MatMenu\n      }]), i0.ɵɵInputTransformsFeature],\n      ngContentSelectors: _c3,\n      decls: 1,\n      vars: 0,\n      consts: [[\"tabindex\", \"-1\", \"role\", \"menu\", 1, \"mat-mdc-menu-panel\", 3, \"click\", \"animationstart\", \"animationend\", \"animationcancel\", \"id\"], [1, \"mat-mdc-menu-content\"]],\n      template: function MatMenu_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵtemplate(0, MatMenu_ng_template_0_Template, 3, 12, \"ng-template\");\n        }\n      },\n      styles: [\"mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;outline:0}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mat-mdc-menu-item-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;flex:1;white-space:normal;font-family:var(--mat-menu-item-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-menu-item-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-menu-item-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-menu-item-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-menu-item-label-text-weight, var(--mat-sys-label-large-weight))}@keyframes _mat-menu-enter{from{opacity:0;transform:scale(0.8)}to{opacity:1;transform:none}}@keyframes _mat-menu-exit{from{opacity:1}to{opacity:0}}.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;box-sizing:border-box;outline:0;animation:_mat-menu-enter 120ms cubic-bezier(0, 0, 0.2, 1);border-radius:var(--mat-menu-container-shape, var(--mat-sys-corner-extra-small));background-color:var(--mat-menu-container-color, var(--mat-sys-surface-container));box-shadow:var(--mat-menu-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12));will-change:transform,opacity}.mat-mdc-menu-panel.mat-menu-panel-exit-animation{animation:_mat-menu-exit 100ms 25ms linear forwards}.mat-mdc-menu-panel.mat-menu-panel-animations-disabled{animation:none}.mat-mdc-menu-panel.mat-menu-panel-animating{pointer-events:none}.mat-mdc-menu-panel.mat-menu-panel-animating:has(.mat-mdc-menu-content:empty){display:none}@media(forced-colors: active){.mat-mdc-menu-panel{outline:solid 1px}}.mat-mdc-menu-panel .mat-divider{color:var(--mat-menu-divider-color, var(--mat-sys-surface-variant));margin-bottom:var(--mat-menu-divider-bottom-spacing, 8px);margin-top:var(--mat-menu-divider-top-spacing, 8px)}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px;padding-left:var(--mat-menu-item-leading-spacing, 12px);padding-right:var(--mat-menu-item-trailing-spacing, 12px);-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-menu-item::-moz-focus-inner{border:0}[dir=rtl] .mat-mdc-menu-item{padding-left:var(--mat-menu-item-trailing-spacing, 12px);padding-right:var(--mat-menu-item-leading-spacing, 12px)}.mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-leading-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-trailing-spacing, 12px)}[dir=rtl] .mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-trailing-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-leading-spacing, 12px)}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:\\\"\\\";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item:focus{outline:0}.mat-mdc-menu-item .mat-icon{flex-shrink:0;margin-right:var(--mat-menu-item-spacing, 12px);height:var(--mat-menu-item-icon-size, 24px);width:var(--mat-menu-item-icon-size, 24px)}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:var(--mat-menu-item-spacing, 12px)}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}@media(forced-colors: active){.mat-mdc-menu-item{margin-top:1px}}.mat-mdc-menu-submenu-icon{width:var(--mat-menu-item-icon-size, 24px);height:10px;fill:currentColor;padding-left:var(--mat-menu-item-spacing, 12px)}[dir=rtl] .mat-mdc-menu-submenu-icon{padding-right:var(--mat-menu-item-spacing, 12px);padding-left:0}[dir=rtl] .mat-mdc-menu-submenu-icon polygon{transform:scaleX(-1);transform-origin:center}@media(forced-colors: active){.mat-mdc-menu-submenu-icon{fill:CanvasText}}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatMenu;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Injection token that determines the scroll handling while the menu is open. */\nconst MAT_MENU_SCROLL_STRATEGY = /*#__PURE__*/new InjectionToken('mat-menu-scroll-strategy', {\n  providedIn: 'root',\n  factory: () => {\n    const overlay = inject(Overlay);\n    return () => overlay.scrollStrategies.reposition();\n  }\n});\n/** @docs-private */\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {\n  return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\nconst MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_MENU_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY\n};\n/** Options for binding a passive event listener. */\nconst passiveEventListenerOptions = /*#__PURE__*/normalizePassiveListenerOptions({\n  passive: true\n});\n/**\n * Default top padding of the menu panel.\n * @deprecated No longer being used. Will be removed.\n * @breaking-change 15.0.0\n */\nconst MENU_PANEL_TOP_PADDING = 8;\n/** Mapping between menu panels and the last trigger that opened them. */\nconst PANELS_TO_TRIGGERS = /*#__PURE__*/new WeakMap();\n/** Directive applied to an element that should trigger a `mat-menu`. */\nlet MatMenuTrigger = /*#__PURE__*/(() => {\n  class MatMenuTrigger {\n    _overlay = inject(Overlay);\n    _element = inject(ElementRef);\n    _viewContainerRef = inject(ViewContainerRef);\n    _menuItemInstance = inject(MatMenuItem, {\n      optional: true,\n      self: true\n    });\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _focusMonitor = inject(FocusMonitor);\n    _ngZone = inject(NgZone);\n    _scrollStrategy = inject(MAT_MENU_SCROLL_STRATEGY);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _portal;\n    _overlayRef = null;\n    _menuOpen = false;\n    _closingActionsSubscription = Subscription.EMPTY;\n    _hoverSubscription = Subscription.EMPTY;\n    _menuCloseSubscription = Subscription.EMPTY;\n    _pendingRemoval;\n    /**\n     * We're specifically looking for a `MatMenu` here since the generic `MatMenuPanel`\n     * interface lacks some functionality around nested menus and animations.\n     */\n    _parentMaterialMenu;\n    /**\n     * Cached value of the padding of the parent menu panel.\n     * Used to offset sub-menus to compensate for the padding.\n     */\n    _parentInnerPadding;\n    /**\n     * Handles touch start events on the trigger.\n     * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.\n     */\n    _handleTouchStart = event => {\n      if (!isFakeTouchstartFromScreenReader(event)) {\n        this._openedBy = 'touch';\n      }\n    };\n    // Tracking input type is necessary so it's possible to only auto-focus\n    // the first item of the list when the menu is opened via the keyboard\n    _openedBy = undefined;\n    /**\n     * @deprecated\n     * @breaking-change 8.0.0\n     */\n    get _deprecatedMatMenuTriggerFor() {\n      return this.menu;\n    }\n    set _deprecatedMatMenuTriggerFor(v) {\n      this.menu = v;\n    }\n    /** References the menu instance that the trigger is associated with. */\n    get menu() {\n      return this._menu;\n    }\n    set menu(menu) {\n      if (menu === this._menu) {\n        return;\n      }\n      this._menu = menu;\n      this._menuCloseSubscription.unsubscribe();\n      if (menu) {\n        if (menu === this._parentMaterialMenu && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throwMatMenuRecursiveError();\n        }\n        this._menuCloseSubscription = menu.close.subscribe(reason => {\n          this._destroyMenu(reason);\n          // If a click closed the menu, we should close the entire chain of nested menus.\n          if ((reason === 'click' || reason === 'tab') && this._parentMaterialMenu) {\n            this._parentMaterialMenu.closed.emit(reason);\n          }\n        });\n      }\n      this._menuItemInstance?._setTriggersSubmenu(this.triggersSubmenu());\n    }\n    _menu;\n    /** Data to be passed along to any lazily-rendered content. */\n    menuData;\n    /**\n     * Whether focus should be restored when the menu is closed.\n     * Note that disabling this option can have accessibility implications\n     * and it's up to you to manage focus, if you decide to turn it off.\n     */\n    restoreFocus = true;\n    /** Event emitted when the associated menu is opened. */\n    menuOpened = new EventEmitter();\n    /**\n     * Event emitted when the associated menu is opened.\n     * @deprecated Switch to `menuOpened` instead\n     * @breaking-change 8.0.0\n     */\n    // tslint:disable-next-line:no-output-on-prefix\n    onMenuOpen = this.menuOpened;\n    /** Event emitted when the associated menu is closed. */\n    menuClosed = new EventEmitter();\n    /**\n     * Event emitted when the associated menu is closed.\n     * @deprecated Switch to `menuClosed` instead\n     * @breaking-change 8.0.0\n     */\n    // tslint:disable-next-line:no-output-on-prefix\n    onMenuClose = this.menuClosed;\n    constructor() {\n      const parentMenu = inject(MAT_MENU_PANEL, {\n        optional: true\n      });\n      this._parentMaterialMenu = parentMenu instanceof MatMenu ? parentMenu : undefined;\n      this._element.nativeElement.addEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);\n    }\n    ngAfterContentInit() {\n      this._handleHover();\n    }\n    ngOnDestroy() {\n      if (this.menu && this._ownsMenu(this.menu)) {\n        PANELS_TO_TRIGGERS.delete(this.menu);\n      }\n      this._element.nativeElement.removeEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);\n      this._pendingRemoval?.unsubscribe();\n      this._menuCloseSubscription.unsubscribe();\n      this._closingActionsSubscription.unsubscribe();\n      this._hoverSubscription.unsubscribe();\n      if (this._overlayRef) {\n        this._overlayRef.dispose();\n        this._overlayRef = null;\n      }\n    }\n    /** Whether the menu is open. */\n    get menuOpen() {\n      return this._menuOpen;\n    }\n    /** The text direction of the containing app. */\n    get dir() {\n      return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /** Whether the menu triggers a sub-menu or a top-level one. */\n    triggersSubmenu() {\n      return !!(this._menuItemInstance && this._parentMaterialMenu && this.menu);\n    }\n    /** Toggles the menu between the open and closed states. */\n    toggleMenu() {\n      return this._menuOpen ? this.closeMenu() : this.openMenu();\n    }\n    /** Opens the menu. */\n    openMenu() {\n      const menu = this.menu;\n      if (this._menuOpen || !menu) {\n        return;\n      }\n      this._pendingRemoval?.unsubscribe();\n      const previousTrigger = PANELS_TO_TRIGGERS.get(menu);\n      PANELS_TO_TRIGGERS.set(menu, this);\n      // If the same menu is currently attached to another trigger,\n      // we need to close it so it doesn't end up in a broken state.\n      if (previousTrigger && previousTrigger !== this) {\n        previousTrigger.closeMenu();\n      }\n      const overlayRef = this._createOverlay(menu);\n      const overlayConfig = overlayRef.getConfig();\n      const positionStrategy = overlayConfig.positionStrategy;\n      this._setPosition(menu, positionStrategy);\n      overlayConfig.hasBackdrop = menu.hasBackdrop == null ? !this.triggersSubmenu() : menu.hasBackdrop;\n      // We need the `hasAttached` check for the case where the user kicked off a removal animation,\n      // but re-entered the menu. Re-attaching the same portal will trigger an error otherwise.\n      if (!overlayRef.hasAttached()) {\n        overlayRef.attach(this._getPortal(menu));\n        menu.lazyContent?.attach(this.menuData);\n      }\n      this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this.closeMenu());\n      menu.parentMenu = this.triggersSubmenu() ? this._parentMaterialMenu : undefined;\n      menu.direction = this.dir;\n      menu.focusFirstItem(this._openedBy || 'program');\n      this._setIsMenuOpen(true);\n      if (menu instanceof MatMenu) {\n        menu._setIsOpen(true);\n        menu._directDescendantItems.changes.pipe(takeUntil(menu.close)).subscribe(() => {\n          // Re-adjust the position without locking when the amount of items\n          // changes so that the overlay is allowed to pick a new optimal position.\n          positionStrategy.withLockedPosition(false).reapplyLastPosition();\n          positionStrategy.withLockedPosition(true);\n        });\n      }\n    }\n    /** Closes the menu. */\n    closeMenu() {\n      this.menu?.close.emit();\n    }\n    /**\n     * Focuses the menu trigger.\n     * @param origin Source of the menu trigger's focus.\n     */\n    focus(origin, options) {\n      if (this._focusMonitor && origin) {\n        this._focusMonitor.focusVia(this._element, origin, options);\n      } else {\n        this._element.nativeElement.focus(options);\n      }\n    }\n    /**\n     * Updates the position of the menu to ensure that it fits all options within the viewport.\n     */\n    updatePosition() {\n      this._overlayRef?.updatePosition();\n    }\n    /** Closes the menu and does the necessary cleanup. */\n    _destroyMenu(reason) {\n      const overlayRef = this._overlayRef;\n      const menu = this._menu;\n      if (!overlayRef || !this.menuOpen) {\n        return;\n      }\n      this._closingActionsSubscription.unsubscribe();\n      this._pendingRemoval?.unsubscribe();\n      // Note that we don't wait for the animation to finish if another trigger took\n      // over the menu, because the panel will end up empty which looks glitchy.\n      if (menu instanceof MatMenu && this._ownsMenu(menu)) {\n        this._pendingRemoval = menu._animationDone.pipe(take(1)).subscribe(() => {\n          overlayRef.detach();\n          menu.lazyContent?.detach();\n        });\n        menu._setIsOpen(false);\n      } else {\n        overlayRef.detach();\n        menu?.lazyContent?.detach();\n      }\n      if (menu && this._ownsMenu(menu)) {\n        PANELS_TO_TRIGGERS.delete(menu);\n      }\n      // Always restore focus if the user is navigating using the keyboard or the menu was opened\n      // programmatically. We don't restore for non-root triggers, because it can prevent focus\n      // from making it back to the root trigger when closing a long chain of menus by clicking\n      // on the backdrop.\n      if (this.restoreFocus && (reason === 'keydown' || !this._openedBy || !this.triggersSubmenu())) {\n        this.focus(this._openedBy);\n      }\n      this._openedBy = undefined;\n      this._setIsMenuOpen(false);\n    }\n    // set state rather than toggle to support triggers sharing a menu\n    _setIsMenuOpen(isOpen) {\n      if (isOpen !== this._menuOpen) {\n        this._menuOpen = isOpen;\n        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n        if (this.triggersSubmenu()) {\n          this._menuItemInstance._setHighlighted(isOpen);\n        }\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     */\n    _createOverlay(menu) {\n      if (!this._overlayRef) {\n        const config = this._getOverlayConfig(menu);\n        this._subscribeToPositions(menu, config.positionStrategy);\n        this._overlayRef = this._overlay.create(config);\n        this._overlayRef.keydownEvents().subscribe(event => {\n          if (this.menu instanceof MatMenu) {\n            this.menu._handleKeydown(event);\n          }\n        });\n      }\n      return this._overlayRef;\n    }\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @returns OverlayConfig\n     */\n    _getOverlayConfig(menu) {\n      return new OverlayConfig({\n        positionStrategy: this._overlay.position().flexibleConnectedTo(this._element).withLockedPosition().withGrowAfterOpen().withTransformOriginOn('.mat-menu-panel, .mat-mdc-menu-panel'),\n        backdropClass: menu.backdropClass || 'cdk-overlay-transparent-backdrop',\n        panelClass: menu.overlayPanelClass,\n        scrollStrategy: this._scrollStrategy(),\n        direction: this._dir || 'ltr'\n      });\n    }\n    /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     */\n    _subscribeToPositions(menu, position) {\n      if (menu.setPositionClasses) {\n        position.positionChanges.subscribe(change => {\n          this._ngZone.run(() => {\n            const posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n            const posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n            menu.setPositionClasses(posX, posY);\n          });\n        });\n      }\n    }\n    /**\n     * Sets the appropriate positions on a position strategy\n     * so the overlay connects with the trigger correctly.\n     * @param positionStrategy Strategy whose position to update.\n     */\n    _setPosition(menu, positionStrategy) {\n      let [originX, originFallbackX] = menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];\n      let [overlayY, overlayFallbackY] = menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\n      let [originY, originFallbackY] = [overlayY, overlayFallbackY];\n      let [overlayX, overlayFallbackX] = [originX, originFallbackX];\n      let offsetY = 0;\n      if (this.triggersSubmenu()) {\n        // When the menu is a sub-menu, it should always align itself\n        // to the edges of the trigger, instead of overlapping it.\n        overlayFallbackX = originX = menu.xPosition === 'before' ? 'start' : 'end';\n        originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n        if (this._parentMaterialMenu) {\n          if (this._parentInnerPadding == null) {\n            const firstItem = this._parentMaterialMenu.items.first;\n            this._parentInnerPadding = firstItem ? firstItem._getHostElement().offsetTop : 0;\n          }\n          offsetY = overlayY === 'bottom' ? this._parentInnerPadding : -this._parentInnerPadding;\n        }\n      } else if (!menu.overlapTrigger) {\n        originY = overlayY === 'top' ? 'bottom' : 'top';\n        originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n      }\n      positionStrategy.withPositions([{\n        originX,\n        originY,\n        overlayX,\n        overlayY,\n        offsetY\n      }, {\n        originX: originFallbackX,\n        originY,\n        overlayX: overlayFallbackX,\n        overlayY,\n        offsetY\n      }, {\n        originX,\n        originY: originFallbackY,\n        overlayX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY\n      }, {\n        originX: originFallbackX,\n        originY: originFallbackY,\n        overlayX: overlayFallbackX,\n        overlayY: overlayFallbackY,\n        offsetY: -offsetY\n      }]);\n    }\n    /** Returns a stream that emits whenever an action that should close the menu occurs. */\n    _menuClosingActions() {\n      const backdrop = this._overlayRef.backdropClick();\n      const detachments = this._overlayRef.detachments();\n      const parentClose = this._parentMaterialMenu ? this._parentMaterialMenu.closed : of();\n      const hover = this._parentMaterialMenu ? this._parentMaterialMenu._hovered().pipe(filter(active => this._menuOpen && active !== this._menuItemInstance)) : of();\n      return merge(backdrop, parentClose, hover, detachments);\n    }\n    /** Handles mouse presses on the trigger. */\n    _handleMousedown(event) {\n      if (!isFakeMousedownFromScreenReader(event)) {\n        // Since right or middle button clicks won't trigger the `click` event,\n        // we shouldn't consider the menu as opened by mouse in those cases.\n        this._openedBy = event.button === 0 ? 'mouse' : undefined;\n        // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n        // we should prevent focus from moving onto it via click to avoid the\n        // highlight from lingering on the menu item.\n        if (this.triggersSubmenu()) {\n          event.preventDefault();\n        }\n      }\n    }\n    /** Handles key presses on the trigger. */\n    _handleKeydown(event) {\n      const keyCode = event.keyCode;\n      // Pressing enter on the trigger will trigger the click handler later.\n      if (keyCode === ENTER || keyCode === SPACE) {\n        this._openedBy = 'keyboard';\n      }\n      if (this.triggersSubmenu() && (keyCode === RIGHT_ARROW && this.dir === 'ltr' || keyCode === LEFT_ARROW && this.dir === 'rtl')) {\n        this._openedBy = 'keyboard';\n        this.openMenu();\n      }\n    }\n    /** Handles click events on the trigger. */\n    _handleClick(event) {\n      if (this.triggersSubmenu()) {\n        // Stop event propagation to avoid closing the parent menu.\n        event.stopPropagation();\n        this.openMenu();\n      } else {\n        this.toggleMenu();\n      }\n    }\n    /** Handles the cases where the user hovers over the trigger. */\n    _handleHover() {\n      // Subscribe to changes in the hovered item in order to toggle the panel.\n      if (this.triggersSubmenu() && this._parentMaterialMenu) {\n        this._hoverSubscription = this._parentMaterialMenu._hovered().subscribe(active => {\n          if (active === this._menuItemInstance && !active.disabled) {\n            this._openedBy = 'mouse';\n            this.openMenu();\n          }\n        });\n      }\n    }\n    /** Gets the portal that should be attached to the overlay. */\n    _getPortal(menu) {\n      // Note that we can avoid this check by keeping the portal on the menu panel.\n      // While it would be cleaner, we'd have to introduce another required method on\n      // `MatMenuPanel`, making it harder to consume.\n      if (!this._portal || this._portal.templateRef !== menu.templateRef) {\n        this._portal = new TemplatePortal(menu.templateRef, this._viewContainerRef);\n      }\n      return this._portal;\n    }\n    /**\n     * Determines whether the trigger owns a specific menu panel, at the current point in time.\n     * This allows us to distinguish the case where the same panel is passed into multiple triggers\n     * and multiple are open at a time.\n     */\n    _ownsMenu(menu) {\n      return PANELS_TO_TRIGGERS.get(menu) === this;\n    }\n    static ɵfac = function MatMenuTrigger_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatMenuTrigger)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatMenuTrigger,\n      selectors: [[\"\", \"mat-menu-trigger-for\", \"\"], [\"\", \"matMenuTriggerFor\", \"\"]],\n      hostAttrs: [1, \"mat-mdc-menu-trigger\"],\n      hostVars: 3,\n      hostBindings: function MatMenuTrigger_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function MatMenuTrigger_click_HostBindingHandler($event) {\n            return ctx._handleClick($event);\n          })(\"mousedown\", function MatMenuTrigger_mousedown_HostBindingHandler($event) {\n            return ctx._handleMousedown($event);\n          })(\"keydown\", function MatMenuTrigger_keydown_HostBindingHandler($event) {\n            return ctx._handleKeydown($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-haspopup\", ctx.menu ? \"menu\" : null)(\"aria-expanded\", ctx.menuOpen)(\"aria-controls\", ctx.menuOpen ? ctx.menu.panelId : null);\n        }\n      },\n      inputs: {\n        _deprecatedMatMenuTriggerFor: [0, \"mat-menu-trigger-for\", \"_deprecatedMatMenuTriggerFor\"],\n        menu: [0, \"matMenuTriggerFor\", \"menu\"],\n        menuData: [0, \"matMenuTriggerData\", \"menuData\"],\n        restoreFocus: [0, \"matMenuTriggerRestoreFocus\", \"restoreFocus\"]\n      },\n      outputs: {\n        menuOpened: \"menuOpened\",\n        onMenuOpen: \"onMenuOpen\",\n        menuClosed: \"menuClosed\",\n        onMenuClose: \"onMenuClose\"\n      },\n      exportAs: [\"matMenuTrigger\"]\n    });\n  }\n  return MatMenuTrigger;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatMenuModule = /*#__PURE__*/(() => {\n  class MatMenuModule {\n    static ɵfac = function MatMenuModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatMenuModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatMenuModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER],\n      imports: [MatRippleModule, MatCommonModule, OverlayModule, CdkScrollableModule, MatCommonModule]\n    });\n  }\n  return MatMenuModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nconst matMenuAnimations = {\n  /**\n   * This animation controls the menu panel's entry and exit from the page.\n   *\n   * When the menu panel is added to the DOM, it scales in and fades in its border.\n   *\n   * When the menu panel is removed from the DOM, it simply fades out after a brief\n   * delay to display the ripple.\n   */\n  transformMenu: /*#__PURE__*/trigger('transformMenu', [/*#__PURE__*/state('void', /*#__PURE__*/style({\n    opacity: 0,\n    transform: 'scale(0.8)'\n  })), /*#__PURE__*/transition('void => enter', /*#__PURE__*/animate('120ms cubic-bezier(0, 0, 0.2, 1)', /*#__PURE__*/style({\n    opacity: 1,\n    transform: 'scale(1)'\n  }))), /*#__PURE__*/transition('* => void', /*#__PURE__*/animate('100ms 25ms linear', /*#__PURE__*/style({\n    opacity: 0\n  })))]),\n  /**\n   * This animation fades in the background color and content of the menu panel\n   * after its containing element is scaled in.\n   */\n  fadeInItems: /*#__PURE__*/trigger('fadeInItems', [\n  /*#__PURE__*/\n  // TODO(crisbeto): this is inside the `transformMenu`\n  // now. Remove next time we do breaking changes.\n  state('showing', /*#__PURE__*/style({\n    opacity: 1\n  })), /*#__PURE__*/transition('void => *', [/*#__PURE__*/style({\n    opacity: 0\n  }), /*#__PURE__*/animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')])])\n};\n/**\n * @deprecated\n * @breaking-change 8.0.0\n * @docs-private\n */\nconst fadeInItems = matMenuAnimations.fadeInItems;\n/**\n * @deprecated\n * @breaking-change 8.0.0\n * @docs-private\n */\nconst transformMenu = matMenuAnimations.transformMenu;\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_MENU_CONTENT, MAT_MENU_DEFAULT_OPTIONS, MAT_MENU_PANEL, MAT_MENU_SCROLL_STRATEGY, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER, MENU_PANEL_TOP_PADDING, MatMenu, MatMenuContent, MatMenuItem, MatMenuModule, MatMenuTrigger, fadeInItems, matMenuAnimations, transformMenu };\n","import { Directive, TemplateRef, ViewContainerRef, inject } from \"@angular/core\";\n\n@Directive({\n  selector: '[ngxDcNavbarRightTopBarContent]',\n  standalone: true\n})\nexport class NgxDcNavbarRightTopBarContentDirective {\n  templateRef = inject<TemplateRef<any>>(TemplateRef);\n  viewContainerRef = inject(ViewContainerRef);\n\n}\n\n@Directive({\n  selector: '[ngxDcNavbarLeftTopBarContent]',\n  standalone: true\n})\nexport class NgxDcNavbarLeftTopBarContentDirective {\n  templateRef = inject<TemplateRef<any>>(TemplateRef);\n  viewContainerRef = inject(ViewContainerRef);\n\n}\n\n\n@Directive({\n  selector: '[ngxDcNavbarMainContent]',\n  standalone: true\n})\nexport class NgxDcNavbarMainContentDirective {\n  templateRef = inject<TemplateRef<any>>(TemplateRef);\n  viewContainerRef = inject(ViewContainerRef);\n\n}\n\n\n@Directive({\n  selector: '[ngxDcNavbarSidebarLinks]',\n  standalone: true\n})\nexport class NgxDcNavbarSidebarLinksDirective {\n  templateRef = inject<TemplateRef<any>>(TemplateRef);\n  viewContainerRef = inject(ViewContainerRef);\n\n}\n\n@Directive({\n  selector: '[ngxDcNavbarSidebar]',\n  standalone: true\n})\nexport class NgxDcNavbarSidebarDirective {\n  templateRef = inject<TemplateRef<any>>(TemplateRef);\n  viewContainerRef = inject(ViewContainerRef);\n\n}\n","import {Injectable, InjectionToken} from '@angular/core';\nimport {BehaviorSubject} from \"rxjs\";\nimport {NgxDcNavbarLinkInfo} from \"./navbar.model\";\nimport {DestroyObservable} from \"@devcrate/ngx-dc-utils\";\n\n/**\n * This service is passed in through the `provideNgxDcNavbarService()` method.\n *\n * To override this default service, then do the following:\n *\n * ```typescript\n * import { Injectable } from '@angular/core'\n *\n * @Injectable()\n * export class MyCustomNavbar extends NgxDcNavbarService<string> {\n *   constructor(private userService: UserService) {}\n *\n *   public isAllowed(allowedList: string[]): boolean {\n *     return this.userService.user.roles.find(role => allowedList.includes(role.name))\n *   }\n * }\n * ```\n *\n * Once implemented, you can then provide the NgxDcNavbarService in your bootstrapApplication config in main.ts\n *\n * ```typescript\n * bootstrapApplication(RootComponent, appConfig)\n *   .catch((err) => console.error(err));\n * ```\n *\n * where the `appConfig` is defined here:\n *\n * ```typescript\n * import {ApplicationConfig} from '@angular/core';\n * import {APP_ROUTES} from './app.routes';\n * import {provideNgxDcNavbarService} from \"@devcrate/ngx-dc-navbar\";\n *\n * export const appConfig: ApplicationConfig = {\n *   providers: [\n *     // ...\n *     provideRouter(APP_ROUTES, withHashLocation()),\n *     // Provide the server here\n *     provideNgxDcNavbarService(MyCustomNavbar),\n *   ]\n * };\n * ```\n */\n@Injectable()\nexport class NgxDcNavbarService<AllowedItemT = string> extends DestroyObservable {\n  /**\n   * Update this value to open and close the sidebar.\n   *\n   * To collapsed$, then do `this.navbarService.collapsed$.next(true)`\n   * To open, then do `this.navbarService.collapsed$.next(false)`\n   */\n  public collapsed$ = new BehaviorSubject<boolean>(true);\n\n  /**\n   * Override this to hide links based on routes.\n   *\n   * When you define the allowedList prop in your `NgxDcNavbarLinkInfo`, this function will be called\n   * with the `allowedList` when the `path` matches the user's path. (when that link is active).\n   *\n   * If you don't override this method, then all links will show, no matter what the allowedList shows.\n   * Its up to you to implement the logic.\n   *\n   * @param allowedList The list of items you define in each `NgxDcNavbarLinkInfo` called `allowedList`.\n   */\n  public isAllowed(allowedList: AllowedItemT[]): boolean {\n    return true\n  }\n}\n\n/**\n * Token used to provide a custom `NgxDcNavbarService`\n */\nexport const NgxDcNavbarServiceToken = new InjectionToken<NgxDcNavbarService>(\"NAVBAR_SERVICE_TOKEN\")\n\n/**\n * Provides a custom navbar service for ngx-dc-navbar.\n *\n * @param NavbarServiceClass The Class to use when using the ngx-dc-navbar. Mainly used to collapse the navbar and define when a link/header and be shown/hidden.\n * @returns Provider that overrides the `NgxDcNavbarServiceToken`\n */\nexport function provideNgxDcNavbarService(NavbarServiceClass?: new (...args: any[]) => NgxDcNavbarService) {\n  return {\n    provide: NgxDcNavbarServiceToken,\n    useClass: NavbarServiceClass || NgxDcNavbarService\n  }\n}\n\n/**\n * Token used to provide a custom list of links to display in the ngx-dc-navbar\n */\nexport const NgxDcNavbarLinksConfig = new InjectionToken<NgxDcNavbarLinkInfo[]>(\"NGX_NAVBAR_LINKS_CONFIG\")\n\n/**\n * Provides custom config of links to display in the ngx-dc-navbar.\n *\n * @param links List of link info to display in the navbar.\n * @returns Provider that overrides the `NgxDcNavbarLinksConfig`\n */\nexport function provideNgxDcNavbarLinksConfig(links: NgxDcNavbarLinkInfo[]) {\n  return {\n    provide: NgxDcNavbarLinksConfig,\n    useValue: links || []\n  }\n}\n","import { AsyncPipe, NgStyle, NgTemplateOutlet } from \"@angular/common\";\nimport { Component, HostListener, OnInit, ViewEncapsulation, contentChild, inject, input } from '@angular/core';\nimport { MatCheckboxModule } from \"@angular/material/checkbox\";\nimport { MatRippleModule } from \"@angular/material/core\";\nimport { MatIconModule } from \"@angular/material/icon\";\nimport { MatListItem, MatNavList } from \"@angular/material/list\";\nimport { MatMenuModule } from \"@angular/material/menu\";\nimport { MatProgressBarModule } from \"@angular/material/progress-bar\";\nimport { MatTooltipModule } from \"@angular/material/tooltip\";\nimport { RouterModule } from \"@angular/router\";\nimport { NgxDcModalService, NgxDcModalServiceToken } from \"@devcrate/ngx-dc-utils\";\nimport {\n  NgxDcNavbarLeftTopBarContentDirective,\n  NgxDcNavbarMainContentDirective,\n  NgxDcNavbarRightTopBarContentDirective,\n  NgxDcNavbarSidebarDirective, NgxDcNavbarSidebarLinksDirective\n} from \"./navbar.directives\";\nimport { NgxDcNavbarLinksConfig, NgxDcNavbarService, NgxDcNavbarServiceToken } from \"./navbar.service\";\n\n@Component({\n    selector: 'ngx-dc-navbar',\n    imports: [\n        MatMenuModule,\n        MatCheckboxModule,\n        MatTooltipModule,\n        RouterModule,\n        MatIconModule,\n        MatProgressBarModule,\n        NgTemplateOutlet,\n        AsyncPipe,\n        MatRippleModule,\n        MatListItem,\n        MatNavList,\n        NgStyle,\n    ],\n    templateUrl: \"navbar.component.html\",\n    styleUrls: [\"navbar.component.scss\"],\n    encapsulation: ViewEncapsulation.None\n})\nexport class NgxDcNavbarComponent implements OnInit {\n  modalService = inject<NgxDcModalService>(NgxDcModalServiceToken);\n  navbarService = inject<NgxDcNavbarService>(NgxDcNavbarServiceToken);\n  links = inject(NgxDcNavbarLinksConfig);\n\n  public readonly mainTitle = input.required<string>();\n  public readonly appLogo = input<string>();\n  public readonly appLogoUrl = input<string>(null);\n  public readonly version = input<string>(null);\n  public readonly topBarBackgroundImage = input<string>(null);\n  public readonly collapseButtonText = input<string>(null);\n  public readonly useCustomLeftTopBar = input<boolean>(false);\n\n  public SMALL_SCREEN_WIDTH = 768;\n  public opened = false;\n  public item: string = ''\n\n  readonly rightTopBarContentTemplate = contentChild(NgxDcNavbarRightTopBarContentDirective);\n  readonly leftTopBarContentTemplate = contentChild(NgxDcNavbarLeftTopBarContentDirective);\n  readonly mainContentTemplate = contentChild(NgxDcNavbarMainContentDirective);\n  readonly sideBarContentTemplate = contentChild(NgxDcNavbarSidebarDirective);\n  readonly sidebarLinksTemplate = contentChild(NgxDcNavbarSidebarLinksDirective);\n\n  @HostListener(\"window:resize\")\n  public onWindowResize() {\n    this.navbarService.collapsed$.next(window?.innerWidth < this.SMALL_SCREEN_WIDTH)\n  }\n\n  async ngOnInit(): Promise<void> {\n    this.onWindowResize()\n  }\n}\n","<div class=\"top-bar mat-elevation-z2\" [ngStyle]=\"topBarBackgroundImage() ? {'background-image': 'url(' + topBarBackgroundImage() + ')'} : {}\">\n  <div class=\"main-title flex flex-row\">\n    @if (!useCustomLeftTopBar()) {\n      @if (appLogoUrl()) {\n        <a [href]=\"appLogoUrl()\"><img class=\"ngx-dc-navbar-icon\" [src]=\"appLogo()\" alt=\"{{mainTitle() + ' Icon'}}\" /></a>\n      } @else {\n        <img class=\"ngx-dc-navbar-icon\" [src]=\"appLogo()\" alt=\"{{mainTitle() + ' Icon'}}\" />\n      }\n      <span class=\"ngx-dc-navbar-title\">{{mainTitle()}}</span>\n    }\n\n    <ng-container *ngTemplateOutlet=\"leftTopBarContentTemplate()?.templateRef\"></ng-container>\n\n  </div>\n  <span class=\"fill\"></span>\n  <ng-container *ngTemplateOutlet=\"rightTopBarContentTemplate()?.templateRef\"></ng-container>\n</div>\n<div class=\"main-container\">\n  @if (sideBarContentTemplate()?.templateRef) {\n    <div class=\"side-bar mat-elevation-z2\" [class.collapsed]=\"navbarService.collapsed$ | async\">\n      <ng-container *ngTemplateOutlet=\"sideBarContentTemplate()?.templateRef; context: {\n        $implicit: navbarService.collapsed$ | async\n      }\"></ng-container>\n    </div>\n  } @else {\n    <div class=\"side-bar mat-elevation-z2\" [class.collapsed]=\"navbarService.collapsed$ | async\">\n      @if (sidebarLinksTemplate()?.templateRef) {\n        <ng-container *ngTemplateOutlet=\"sidebarLinksTemplate()?.templateRef; context: {\n          $implicit: navbarService.collapsed$ | async\n        }\"></ng-container>\n      } @else {\n        <mat-nav-list class=\"menu-navigation\">\n          @for (menuItem of links; track menuItem.title) {\n            @if (navbarService.isAllowed(menuItem.allowedList)) {\n              @if (menuItem.type === 'heading') {\n                <mat-list-item disabled class=\"menu-title heading\"\n                               [class.align-items-center]=\"navbarService.collapsed$ | async\">\n                  @if (!(navbarService.collapsed$ | async)) {\n                    {{ menuItem.title }}\n                  } @else {\n                    <hr/>\n                  }\n                </mat-list-item>\n              }\n\n              @if (menuItem.type === 'link') {\n                <a\n                  [matTooltip]=\"menuItem.title\"\n                  [matTooltipDisabled]=\"!opened\"\n                  matTooltipPosition=\"right\"\n                  routerLinkActive=\"link-active\"\n                  [routerLink]=\"menuItem.path\"\n                  data-testid=\"menu-link-link\"\n                >\n                  <mat-list-item [matTooltip]=\"menuItem.title\" [matTooltipDisabled]=\"!(navbarService.collapsed$ | async)\"\n                                 matTooltipPosition=\"right\">\n                    <div class=\"flex align-items-center nav-item\">\n                      @if (menuItem.icon?.includes('svg:')) {\n                        <mat-icon class=\"\" [svgIcon]=\"menuItem.icon.replace('svg:', '')\"></mat-icon>\n                      } @else {\n                        <mat-icon>{{ menuItem.icon }}</mat-icon>\n                      }\n                      <span class=\"menu-item-title\">{{ menuItem.title }}</span>\n                    </div>\n                  </mat-list-item>\n                </a>\n              }\n\n              @if (menuItem.hasDivider) {\n                <hr class=\"ngx-dc-navbar-divider\" />\n              }\n            }\n          }\n        </mat-nav-list>\n      }\n      <span class=\"fill\"></span>\n      <hr class=\"end-sidebar-separator\"/>\n      <mat-nav-list class=\"no-padding\">\n        <mat-list-item class=\"collapse-version-group heading\" data-testid=\"menu-collapse-button\" matRipple\n                       (click)=\"navbarService.collapsed$.next(!navbarService.collapsed$.value)\">\n          <div class=\"flex align-items-center justify-content-center\">\n          <span class=\"version-info\">\n            @if (collapseButtonText()) {\n              {{ collapseButtonText() }}\n            } @else {\n              {{ mainTitle() }} {{ version() || '' }}\n            }\n          </span>\n            <span class=\"fill collapse-fill\"></span>\n            <mat-icon class=\"double-arrow\">double_arrow</mat-icon>\n          </div>\n        </mat-list-item>\n      </mat-nav-list>\n    </div>\n  }\n  <div class=\"main-content\">\n    @if (modalService.showGlobalLoadingBar | async) {\n      <mat-progress-bar\n        color=\"primary\"\n        [class.collapsed]=\"navbarService.collapsed$ | async\"\n        mode=\"indeterminate\"\n        class=\"global-progress-bar\"\n        data-testid=\"app-global-loader\"\n      ></mat-progress-bar>\n    }\n    <ng-container *ngTemplateOutlet=\"mainContentTemplate()?.templateRef\"></ng-container>\n  </div>\n</div>\n","import { ModuleWithProviders, NgModule } from '@angular/core';\n\nimport { NgxDcNavbarComponent } from './navbar.component';\nimport {\n  NgxDcNavbarLeftTopBarContentDirective,\n  NgxDcNavbarMainContentDirective,\n  NgxDcNavbarRightTopBarContentDirective,\n  NgxDcNavbarSidebarDirective, NgxDcNavbarSidebarLinksDirective\n} from \"./navbar.directives\";\nimport { NgxDcNavbarLinkInfo } from \"./navbar.model\";\nimport {\n  NgxDcNavbarService,\n  provideNgxDcNavbarLinksConfig,\n  provideNgxDcNavbarService\n} from \"./navbar.service\";\n\nexport const IMPORTS = [\n  NgxDcNavbarComponent,\n  NgxDcNavbarLeftTopBarContentDirective,\n  NgxDcNavbarRightTopBarContentDirective,\n  NgxDcNavbarMainContentDirective,\n  NgxDcNavbarSidebarDirective,\n  NgxDcNavbarSidebarLinksDirective,\n]\n\n/**\n * Usage:\n *\n * ```typescript\n * @NgModule({\n *   imports: [NgxDcNavbarModule],\n * })\n * export class AppModule {}\n * ```\n *\n * If you want to handle roles in your app, then do this:\n *\n * ```typescript\n * import { Injectable } from '@angular/core'\n * import { NavbarService } from '@devcrate/ngx-dc-navbar'\n *\n * @Injectable()\n * export class MyNavbarService extends NavbarService {\n *   constructor(\n *     public router: Router,\n *     public route: ActivatedRoute,\n *     public userService: UserService\n *   ) {\n *     super()\n *     this.route = route\n *     this.router = router\n *   }\n *\n *   public isAllowed(allowedList: string[]): boolean {\n *     // This function is called whenever a route is navigated. It looks at the route, and checks if the route\n *     // is defined in your links data object. If it has `allowedRoles` array, defined, then it will call this method\n *     // with that list as the param rolesAllowed.\n *     // Implement your logic to return true or false on whether your user has these roles\n *     return allowedList.includes(userService.user.role)\n *   }\n *\n *   public ngOnDestroy() {\n *     this.onDestroy()\n *   }\n * }\n *\n * @NgModule({\n *   imports: [NgxDcNavbarModule.forRoot(MyNavbarService)],\n * })\n * export class AppModule {}\n * ```\n */\n@NgModule({\n  imports: IMPORTS,\n  exports: IMPORTS,\n})\nexport class NgxDcNavbarModule {\n  /**\n   * Use this when using lazy-loaded modules and routing modules. DO NOT USE FOR STANDALONE apps/components.\n   * Only use in the root module. Not in child modules. Wherever you use RouterModule.forChild, use forChild. Same for forRoot.\n   * @param links\n   * @param ProvidedNavbarService\n   */\n  public static forRoot(links?: NgxDcNavbarLinkInfo[], ProvidedNavbarService?: new (...args: any[]) => NgxDcNavbarService): ModuleWithProviders<NgxDcNavbarModule> {\n    return {\n      ngModule: NgxDcNavbarModule,\n      providers: [\n        provideNgxDcNavbarService(ProvidedNavbarService || NgxDcNavbarService),\n        provideNgxDcNavbarLinksConfig(links || []),\n      ],\n    };\n  }\n\n  /**\n   * Use this when:\n   * State Needs to Be Separate: If each lazy-loaded module should have its own NavbarService instance (for different navbar links, for instance).\n   * Configuration is Unique: If you want each module to configure the NavbarService differently, especially if different routes or data properties need to be handled separately.\n   */\n  static forChild(links?: NgxDcNavbarLinkInfo[], ProvidedNavbarService?: new (...args: any[]) => NgxDcNavbarService): ModuleWithProviders<NgxDcNavbarModule> {\n    return {\n      ngModule: NgxDcNavbarModule,\n      providers: [\n        provideNgxDcNavbarService(ProvidedNavbarService || NgxDcNavbarService),\n        provideNgxDcNavbarLinksConfig(links || []),\n      ],\n    };\n  }\n}\n","/*\n * Public API Surface of ngx-dc-navbar\n */\n\nexport * from './lib/navbar.component';\nexport * from './lib/navbar.directives';\nexport * from './lib/navbar.model';\nexport * from './lib/navbar.service';\nexport * from './lib/navbar.module';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"mappings":"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","names":["_c0","_c1","_c2","MAT_CHECKBOX_DEFAULT_OPTIONS","InjectionToken","MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY","TransitionCheckState","MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","MatCheckbox","MatCheckboxChange","defaults","inject","ElementRef","ChangeDetectorRef","NgZone","ANIMATION_MODULE_TYPE","isChecked","event","EventEmitter","_CdkPrivateStyleLoader","_StructuralStylesLoader","tabIndex","HostAttributeToken","_IdGenerator","changes","value","changed","fn","isDisabled","control","newState","oldState","element","animationClass","clickAction","nativeCheckbox","__ngFactoryType__","ɵɵdefineComponent","rf","ctx","ɵɵviewQuery","_t","ɵɵqueryRefresh","ɵɵloadQuery","ɵɵhostProperty","ɵɵattribute","ɵɵclassMap","ɵɵclassProp","booleanAttribute","numberAttribute","ɵɵProvidersFeature","NG_VALIDATORS","ɵɵInputTransformsFeature","ɵɵNgOnChangesFeature","_r1","ɵɵgetCurrentView","ɵɵprojectionDef","ɵɵelementStart","ɵɵlistener","$event","ɵɵrestoreView","ɵɵresetView","ɵɵelementEnd","ɵɵelement","ɵɵnamespaceSVG","ɵɵnamespaceHTML","ɵɵprojection","checkbox_r2","ɵɵreference","ɵɵproperty","ɵɵadvance","MatRipple","_MatInternalFormField","MatCheckboxModule","__ngFactoryType__","ɵɵdefineNgModule","ɵɵdefineInjector","MatCheckbox","MatCommonModule","MAT_MENU_SCROLL_STRATEGY","InjectionToken","overlay","inject","Overlay","MAT_MENU_SCROLL_STRATEGY_FACTORY","MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER","MatMenuModule","__ngFactoryType__","ɵɵdefineNgModule","ɵɵdefineInjector","MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER","MatRippleModule","MatCommonModule","OverlayModule","CdkScrollableModule","matMenuAnimations","trigger","state","style","transition","animate","fadeInItems","transformMenu","rf","ctx_r0","ɵɵnextContext","NgxDcNavbarComponent_Conditional_2_Conditional_1_Template","ctx","NgxDcNavbarComponent_Conditional_2_Template","NgxDcNavbarComponent_ng_container_3_Template","NgxDcNavbarComponent_ng_container_5_Template","NgxDcNavbarComponent_Conditional_7_ng_container_2_Template","NgxDcNavbarComponent_Conditional_7_Template","tmp_2_0","ɵɵpureFunction1","_c2","ɵɵpipeBind1","NgxDcNavbarComponent_Conditional_8_Conditional_2_ng_container_0_Template","NgxDcNavbarComponent_Conditional_8_Conditional_2_Template","NgxDcNavbarComponent_Conditional_8_Conditional_3_For_2_Conditional_0_Conditional_0_Conditional_2_Template","menuItem_r3","NgxDcNavbarComponent_Conditional_8_Conditional_3_For_2_Conditional_0_Conditional_0_Conditional_4_Template","NgxDcNavbarComponent_Conditional_8_Conditional_3_For_2_Conditional_0_Conditional_0_Template","NgxDcNavbarComponent_Conditional_8_Conditional_3_For_2_Conditional_0_Conditional_1_Conditional_4_Template","NgxDcNavbarComponent_Conditional_8_Conditional_3_For_2_Conditional_0_Conditional_1_Conditional_5_Template","NgxDcNavbarComponent_Conditional_8_Conditional_3_For_2_Conditional_0_Conditional_1_Template","opened","path","NgxDcNavbarComponent_Conditional_8_Conditional_3_For_2_Conditional_0_Conditional_2_Template","NgxDcNavbarComponent_Conditional_8_Conditional_3_For_2_Conditional_0_Template","NgxDcNavbarComponent_Conditional_8_Conditional_3_For_2_Template","$implicit","NgxDcNavbarComponent_Conditional_8_Conditional_3_Template","NgxDcNavbarComponent_Conditional_8_Conditional_10_Template","NgxDcNavbarComponent_Conditional_8_Conditional_11_Template","NgxDcNavbarComponent_Conditional_8_Template","_r2","ɵɵgetCurrentView","navbarService","collapsed$","next","value","NgxDcNavbarComponent_Conditional_10_Template","NgxDcNavbarComponent_ng_container_12_Template","NgxDcNavbarRightTopBarContentDirective","templateRef","inject","TemplateRef","viewContainerRef","ViewContainerRef","selectors","NgxDcNavbarLeftTopBarContentDirective","NgxDcNavbarMainContentDirective","NgxDcNavbarSidebarLinksDirective","NgxDcNavbarSidebarDirective","NgxDcNavbarService","DestroyObservable","BehaviorSubject","isAllowed","allowedList","__ngFactoryType__","factory","ɵfac","NgxDcNavbarServiceToken","InjectionToken","provideNgxDcNavbarService","NavbarServiceClass","provide","useClass","NgxDcNavbarLinksConfig","provideNgxDcNavbarLinksConfig","links","useValue","NgxDcNavbarComponent","modalService","NgxDcModalServiceToken","mainTitle","input","required","appLogo","appLogoUrl","version","topBarBackgroundImage","collapseButtonText","useCustomLeftTopBar","SMALL_SCREEN_WIDTH","item","rightTopBarContentTemplate","contentChild","leftTopBarContentTemplate","mainContentTemplate","sideBarContentTemplate","sidebarLinksTemplate","onWindowResize","window","innerWidth","ngOnInit","__async","ɵcmp","ɵɵdefineComponent","contentQueries","dirIndex","ɵɵresolveWindow","inputs","decls","vars","consts","template","tmp_3_0","tmp_4_0","tmp_6_0","dependencies","MatMenuModule","MatCheckboxModule","MatTooltipModule","MatTooltip","RouterModule","RouterLink","RouterLinkActive","MatIconModule","MatIcon","MatProgressBarModule","MatProgressBar","NgTemplateOutlet","AsyncPipe","MatRippleModule","MatRipple","MatListItem","MatNavList","NgStyle","styles","encapsulation","NgxDcNavbarModule","forRoot","links","ProvidedNavbarService","ngModule","providers","provideNgxDcNavbarService","NgxDcNavbarService","provideNgxDcNavbarLinksConfig","forChild","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","NgxDcNavbarComponent"],"x_google_ignoreList":[0,1]}